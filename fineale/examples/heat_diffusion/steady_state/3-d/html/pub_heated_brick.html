
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Heated brick.  Solution with  linear hexahedra (H8).</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-12-19"><meta name="DC.source" content="pub_heated_brick.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Heated brick.  Solution with  linear hexahedra (H8).</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Description</a></li><li><a href="#5">Solution</a></li><li><a href="#40">Discussion</a></li></ul></div><p>Link to the  <a href="matlab:edit('pub_heated_brick')">m-file</a>.</p><h2>Description<a name="2"></a></h2><p>The brick represented in Figure 1 has insulated lateral surfaces (BCGF, CDHG, DAEH, ABFE).  The  surface  ABCD  is  maintained  at  constant temperature  T  =  0  degrees,  and  the temperature is linearly distributed at EFGH surface so that T = 0 degrees at E point, T = 1 degrees at H and T = 2 degrees at point F. Find temperature at the point P. The reference solution for the temperature at point P is 0.901 degrees. Thermal conductivity <img src="pub_heated_brick_eq03188964142886151932.png" alt="$\kappa = 1$">.</p><p>
<table border=0><tr><td>
<img src="../docs/pub_heated_brick_2.jpg">
</td></tr>
<tr><td>Figure 1. Definition of the geometry of the heated brick</td></tr>
</table>
</p><p>Analytical solution is due to the Reference M. Necati Ozisik &#8220;Boundary Value Problems of Heat Conduction&#8221;.  Dover Publications, INC., N.Y. 1989.</p><h2>Solution<a name="5"></a></h2><p>It is good practice to put code into functions as we can avoid trouble due to shared global workspace variables.   All variables in this function are private.</p><pre class="codeinput"><span class="keyword">function</span> pub_heated_brick
</pre><p>Definition of the geometry: The locations of the points.</p><pre class="codeinput">    A=[0,0,0]; B=[0,0,2]; C=[0,3,2]; D=[0,3,0];
    E=[5,0,0]; F=[5,0,2]; G=[5,3,2]; H=[5,3,0];
    P=[3.75,0,0];
</pre><p>Define the material properties.</p><pre class="codeinput">    kappa= 1.0;
</pre><p>Generate the mesh by meshing two general hexahedra and merging them into a single mesh.</p><pre class="codeinput">    [fens,fes] = H8_hexahedron([A;P;(D+H)/2;D;B;(B+F)/2;(C+G)/2;C],1,1,1,[]);
    [fens1,fes1] = H8_hexahedron([P;E;H;(D+H)/2;(B+F)/2;F;G;(C+G)/2],1,1,1,[]);
    [fens,fes1,fes2] = merge_meshes(fens1, fes1, fens, fes, 1/1000);
    fes=cat(fes1,fes2);
</pre><p>Next, the two-element mesh is refined by trisection. Applying trisection twice means the mesh is going to consist of 64 hexahedra.</p><pre class="codeinput">    [fens,fes]=H8_refine(fens,fes);
    [fens,fes]=H8_refine(fens,fes);
</pre><p>The mesh is displayed with the elements shrunk.</p><pre class="codeinput">    gv=drawmesh({fens,fes},<span class="string">'fes'</span>,<span class="string">'facecolor'</span>,<span class="string">'red'</span>,<span class="string">'shrink'</span>, 0.9);
    labels ([])
</pre><img vspace="5" hspace="5" src="pub_heated_brick_01.png" alt=""> <p>In this tutorial we are going to use an approach to the solution which spells out the creation of all the necessary objects of the analysis instead of  invoking a steady-state heat conduction solver.  To inspect the latter option, refer to the tutorial <a href="pub_heated_brick_alt.html">pub_heated_brick_alt.html</a>.</p><p>First step: We are going to create the  thermal property and the thermal material objects.</p><pre class="codeinput">    prop=property_heat_diffusion(struct(<span class="string">'thermal_conductivity'</span>,kappa,<span class="string">'source'</span>,0.0));
    mater=material_heat_diffusion (struct(<span class="string">'property'</span>,prop));
</pre><p>The finite element model machine for heat diffusion. Note that the Gauss rule of order two is the minimum required for stability of the calculation.</p><pre class="codeinput">    femm = femm_heat_diffusion (struct (<span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'fes'</span>,fes,<span class="keyword">...</span>
        <span class="string">'integration_rule'</span>,gauss_rule(struct( <span class="string">'dim'</span>,3,<span class="string">'order'</span>,2))));
</pre><p>The geometry nodal field is created from the finite element node set.</p><pre class="codeinput">    geom = nodal_field(struct(<span class="string">'name'</span>,[<span class="string">'geom'</span>], <span class="string">'dim'</span>, 3, <span class="string">'fens'</span>,fens));
</pre><p>The temperature field has one degree of freedom per node.</p><pre class="codeinput">    temp=nodal_field(struct(<span class="string">'name'</span>,[<span class="string">'temp'</span>], <span class="string">'dim'</span>, 1, <span class="string">'nfens'</span>,geom.nfens));
</pre><p>The essential boundary conditions are applied next.</p><p>Essential boundary condition: zero temperature on face ABCD. The nodes located on this face are selected using a 'box' criterion.</p><pre class="codeinput">    fenids=fenode_select(fens,struct(<span class="string">'box'</span>,[A(1),A(1),-inf,inf,-inf,inf],<span class="keyword">...</span>
        <span class="string">'inflate'</span>, 1/1000)) ;
    temp = set_ebc(temp, fenids, true, [], 0.0);
    temp = apply_ebc (temp);
</pre><p>Essential boundary condition: linearly-varying temperature on face EFGH. The nodes are selected using a box.   The locations of the selected nodes are <tt>fens.xyz(nl,:)</tt>, so that <tt>1.0*fens.xyz(nl,2)/H(2)</tt> describes the gradient of the temperature in the Y-direction and the temperatures at the nodes <tt>fixed_temperatures</tt> may be therefore evaluated as shown below.</p><pre class="codeinput">    fenids=fenode_select(fens,struct(<span class="string">'box'</span>,[E(1),E(1),-inf,inf,-inf,inf],<span class="keyword">...</span>
        <span class="string">'inflate'</span>, 1/1000)) ;
    fixed_temperatures =1.0*fens.xyz(fenids,2)/H(2)+2.0*fens.xyz(fenids,3)/F(3);
    temp = set_ebc(temp, fenids, true, [], fixed_temperatures);
    temp = apply_ebc (temp);
</pre><p>Number the free degrees of freedom</p><pre class="codeinput">    temp = numberdofs (temp);
</pre><p>Calculate and assemble the conductivity matrix.</p><pre class="codeinput">    K = conductivity(femm, sysmat_assembler_sparse, geom, temp);
</pre><p>Calculate and assemble the non-zero-EBC heat load.</p><pre class="codeinput">    F =  nz_ebc_loads_conductivity(femm, sysvec_assembler, geom, temp);
</pre><p>Compute the values of the temperature for the free degrees of freedom and distribute the results to the nodal field.</p><pre class="codeinput">    temp = scatter_sysvec(temp, K\F);
</pre><p>Graphical rendering  of the computed temperatures. First we show the temperature displayed with filled surfaces on the boundary of the mesh color-coded  with the temperature.</p><p>Create the graphics viewer and reset the view. Note: so that we don't have to see all the intermediate figures in the published output, we create the figure as invisible, and then we turn it on when we call interact().</p><pre class="codeinput">    close <span class="string">all</span>
    figure(<span class="string">'visible'</span>, <span class="string">'off'</span>)
    gv=graphic_viewer;
    gv=reset (gv,struct(<span class="string">'axes'</span>,gca));
</pre><p>Create the data colormap object for mapping temperatures to colors.</p><pre class="codeinput">    dcm=data_colormap(struct(<span class="string">'range'</span>,[min(temp.values),max(temp.values)],<span class="string">'colormap'</span>,hot));
</pre><p>Create the color field, with colors at nodes.  The colors will be interpolated using the finite element basis functions on the mesh.</p><pre class="codeinput">    colorfield=nodal_field(struct (<span class="string">'name'</span>, [<span class="string">'colorfield'</span>], <span class="string">'data'</span>,<span class="keyword">...</span>
        map_data(dcm, temp.values)));
</pre><p>Plot the color field on the surface of the brick.</p><pre class="codeinput">    draw(mesh_boundary(femm.fes, []), gv, struct (<span class="string">'x'</span>,geom, <span class="string">'u'</span>,0*geom,<span class="keyword">...</span>
        <span class="string">'colorfield'</span>,colorfield, <span class="string">'shrink'</span>,1));
</pre><p>Add the color bar</p><pre class="codeinput">    draw_colorbar(gv, struct(<span class="string">'colormap'</span>,dcm.colormap,<span class="string">'label'</span>,<span class="string">'Temperature'</span>,<span class="keyword">...</span>
        <span class="string">'minmax'</span>,[min(temp.values),max(temp.values)]));
</pre><p>Add the labels to the axes...</p><pre class="codeinput">    labels ([])
</pre><p>...and make the figure visible and interact with the view.</p><pre class="codeinput">    interact(gv);
</pre><img vspace="5" hspace="5" src="pub_heated_brick_02.png" alt=""> <p>We are going to present the temperatures using isosurfaces.  These are surfaces of constant temperature, which are going to be color-coded using a map from temperatures to colors.</p><p>Create the graphics viewer and reset the view.</p><pre class="codeinput">    close <span class="string">all</span>
    figure(<span class="string">'visible'</span>, <span class="string">'off'</span>)
    gv=graphic_viewer;
    gv=reset (gv,struct(<span class="string">'axes'</span>,gca));
</pre><p>Create the data colormap object for mapping temperatures to colors.</p><pre class="codeinput">    dcm=data_colormap(struct(<span class="string">'range'</span>,[min(temp.values),max(temp.values)],<span class="string">'colormap'</span>,hot));
</pre><p>Plot the boundary surface of the brick in wireframe rendering for reference.</p><pre class="codeinput">    draw(mesh_boundary (femm.fes, []), gv, struct (<span class="string">'x'</span>,geom, <span class="string">'u'</span>,0*geom,<span class="keyword">...</span>
        <span class="string">'facecolor'</span>,<span class="string">'none'</span>));
    <span class="keyword">for</span> isovalue = [0.5:0.25:3.0]
        draw_isosurface(fes,  gv, struct (<span class="string">'x'</span>,geom, <span class="string">'u'</span>,0*geom,<span class="keyword">...</span>
            <span class="string">'scalarfield'</span>,temp,<span class="string">'isovalue'</span>,isovalue,<span class="string">'color'</span>,map_data(dcm, isovalue)));
    <span class="keyword">end</span>
</pre><p>Add the color bar</p><pre class="codeinput">    draw_colorbar(gv, struct(<span class="string">'colormap'</span>,dcm.colormap,<span class="string">'label'</span>,<span class="string">'Temperature'</span>,<span class="keyword">...</span>
        <span class="string">'minmax'</span>,[min(temp.values),max(temp.values)]));
</pre><p>Add the labels to the axes...</p><pre class="codeinput">    labels ([])
</pre><p>Add lighting to aid in the interpretation of the scene.</p><pre class="codeinput">    headlight(gv);
</pre><p>...and make the figure visible and interact with the view.</p><pre class="codeinput">    interact(gv);
</pre><img vspace="5" hspace="5" src="pub_heated_brick_03.png" alt=""> <h2>Discussion<a name="40"></a></h2><p>Temperature at point P: Find the node at that point using a bounding box,...</p><pre class="codeinput">    Pid=fenode_select(fens,struct(<span class="string">'box'</span>,bounding_box(P),<span class="keyword">...</span>
        <span class="string">'inflate'</span>, 1/1000)) ;
</pre><p>...  and retrieve the temperature:</p><pre class="codeinput">    temp.values(Pid)
</pre><pre class="codeoutput">
ans =

   9.2337e-01

</pre><p>This may be compared with the analytical solution of 0.901 degrees at point P. With the given mesh we are therefore within 2.5% of the analytical solution.</p><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Heated brick.  Solution with  linear hexahedra (H8).
%

%%
% Link to the  <matlab:edit('pub_heated_brick') m-file>.
%

%% Description
%
% The brick represented in Figure 1 has insulated lateral surfaces (BCGF,
% CDHG, DAEH, ABFE).  The  surface  ABCD  is  maintained  at  constant
% temperature  T  =  0  degrees,  and  the temperature is linearly
% distributed at EFGH surface so that T = 0 degrees at E point, T = 1
% degrees at H and T = 2 degrees at point F. Find temperature at the point
% P. The reference solution for the temperature at point P is 0.901 degrees. Thermal
% conductivity $\kappa = 1$.
%
%%
%
% <html>
% <table border=0><tr><td>
% <img src="../docs/pub_heated_brick_2.jpg">
% </td></tr>
% <tr><td>Figure 1. Definition of the geometry of the heated brick</td></tr>
% </table>
% </html>

%%
%
% Analytical solution is due to the Reference
% M. Necati Ozisik “Boundary Value Problems of Heat Conduction”.  Dover Publications,
% INC., N.Y. 1989.

%% Solution
%
% It is good practice to put code into functions as we can avoid trouble
% due to shared global workspace variables.   All variables in this
% function are private.
function pub_heated_brick
    
    %%
    % Definition of the geometry: The locations of the points.
    A=[0,0,0]; B=[0,0,2]; C=[0,3,2]; D=[0,3,0];
    E=[5,0,0]; F=[5,0,2]; G=[5,3,2]; H=[5,3,0];
    P=[3.75,0,0];
    
    %%
    % Define the material properties.
    kappa= 1.0;
    
    
    %%
    % Generate the mesh by meshing two general hexahedra and merging them into
    % a single mesh.
    [fens,fes] = H8_hexahedron([A;P;(D+H)/2;D;B;(B+F)/2;(C+G)/2;C],1,1,1,[]);
    [fens1,fes1] = H8_hexahedron([P;E;H;(D+H)/2;(B+F)/2;F;G;(C+G)/2],1,1,1,[]);
    [fens,fes1,fes2] = merge_meshes(fens1, fes1, fens, fes, 1/1000);
    fes=cat(fes1,fes2);
    
    %%
    % Next, the two-element mesh is refined by trisection. Applying
    % trisection twice means the mesh is going to consist of 64 hexahedra.
    [fens,fes]=H8_refine(fens,fes);
    [fens,fes]=H8_refine(fens,fes);
    %%
    % The mesh is displayed with the elements shrunk.
    gv=drawmesh({fens,fes},'fes','facecolor','red','shrink', 0.9);
    labels ([])
    
%% 
% In this tutorial we are going to use an approach to the solution which
% spells out the creation of all the necessary objects of the analysis
% instead of  invoking a steady-state heat conduction solver.  To inspect
% the latter option, refer to the tutorial <pub_heated_brick_alt.html>.

    %%
    % First step: We are going to create the  thermal
    % property and the thermal material objects.
    prop=property_heat_diffusion(struct('thermal_conductivity',kappa,'source',0.0));
    mater=material_heat_diffusion (struct('property',prop));
    
    %%
    % The finite element model machine for heat diffusion. Note that the Gauss
    % rule of order two is the minimum required for stability of the
    % calculation.
    femm = femm_heat_diffusion (struct ('material',mater,...
        'fes',fes,...
        'integration_rule',gauss_rule(struct( 'dim',3,'order',2))));
    
    %%
    % The geometry nodal field is created from the finite element node set.
    geom = nodal_field(struct('name',['geom'], 'dim', 3, 'fens',fens));
    %%
    % The temperature field has one degree of freedom per node.
    temp=nodal_field(struct('name',['temp'], 'dim', 1, 'nfens',geom.nfens));
    
    %%
    % The essential boundary conditions are applied next.
    %%
    % Essential boundary condition: zero temperature on face ABCD. The
    % nodes located on this face are selected using a 'box' criterion. 
    fenids=fenode_select(fens,struct('box',[A(1),A(1),-inf,inf,-inf,inf],...
        'inflate', 1/1000)) ;
    temp = set_ebc(temp, fenids, true, [], 0.0);
    temp = apply_ebc (temp);
    
    %%
    % Essential boundary condition: linearly-varying temperature on face EFGH.
    % The nodes are selected using a box.   The locations of the selected
    % nodes are |fens.xyz(nl,:)|, so that |1.0*fens.xyz(nl,2)/H(2)|
    % describes the gradient of the temperature in the Y-direction and the
    % temperatures at the nodes |fixed_temperatures| may be therefore
    % evaluated as shown below. 
    fenids=fenode_select(fens,struct('box',[E(1),E(1),-inf,inf,-inf,inf],...
        'inflate', 1/1000)) ;
    fixed_temperatures =1.0*fens.xyz(fenids,2)/H(2)+2.0*fens.xyz(fenids,3)/F(3);
    temp = set_ebc(temp, fenids, true, [], fixed_temperatures);
    temp = apply_ebc (temp);
    
    %%
    % Number the free degrees of freedom
    temp = numberdofs (temp);
    
    %%
    % Calculate and assemble the conductivity matrix.
    K = conductivity(femm, sysmat_assembler_sparse, geom, temp);
    
    %%
    % Calculate and assemble the non-zero-EBC heat load.
    F =  nz_ebc_loads_conductivity(femm, sysvec_assembler, geom, temp);
    
    %%
    % Compute the values of the temperature for the free degrees of freedom and
    % distribute the results to the nodal field.
    temp = scatter_sysvec(temp, K\F);
    
    %%
    % Graphical rendering  of the computed temperatures. First we show the
    % temperature displayed with filled surfaces on the boundary of the mesh
    % color-coded  with the temperature.
    %%
    % Create the graphics viewer and reset the view. Note: so that we don't have to
    % see all the intermediate figures in the published output, we create
    % the figure as invisible, and then we turn it on when we call interact().
    close all
    figure('visible', 'off')
    gv=graphic_viewer;
    gv=reset (gv,struct('axes',gca));
    
    %%
    % Create the data colormap object for mapping temperatures to colors.
    dcm=data_colormap(struct('range',[min(temp.values),max(temp.values)],'colormap',hot));
    %%
    % Create the color field, with colors at nodes.  The colors will be
    % interpolated using the finite element basis functions on the mesh.
    colorfield=nodal_field(struct ('name', ['colorfield'], 'data',...
        map_data(dcm, temp.values)));
    
    %%
    % Plot the color field on the surface of the brick.
    draw(mesh_boundary(femm.fes, []), gv, struct ('x',geom, 'u',0*geom,...
        'colorfield',colorfield, 'shrink',1));
    
    %%
    % Add the color bar
    draw_colorbar(gv, struct('colormap',dcm.colormap,'label','Temperature',...
        'minmax',[min(temp.values),max(temp.values)]));
    %%
    % Add the labels to the axes...
    labels ([])
    %%
    % ...and make the figure visible and interact with the view.
    interact(gv);
    
    
    %%
    % We are going to present the temperatures using isosurfaces.  These are
    % surfaces of constant temperature, which are going to be color-coded using
    % a map from temperatures to colors.
    %%
    % Create the graphics viewer and reset the view.
    close all
    figure('visible', 'off')
    gv=graphic_viewer;
    gv=reset (gv,struct('axes',gca));
    
    %%
    % Create the data colormap object for mapping temperatures to colors.
    dcm=data_colormap(struct('range',[min(temp.values),max(temp.values)],'colormap',hot));
    
    %%
    % Plot the boundary surface of the brick in wireframe rendering for reference.
    draw(mesh_boundary (femm.fes, []), gv, struct ('x',geom, 'u',0*geom,...
        'facecolor','none'));
    for isovalue = [0.5:0.25:3.0]
        draw_isosurface(fes,  gv, struct ('x',geom, 'u',0*geom,...
            'scalarfield',temp,'isovalue',isovalue,'color',map_data(dcm, isovalue)));
    end
    %%
    % Add the color bar
    draw_colorbar(gv, struct('colormap',dcm.colormap,'label','Temperature',...
        'minmax',[min(temp.values),max(temp.values)]));
    %%
    % Add the labels to the axes...
    labels ([])
    
    %%
    % Add lighting to aid in the interpretation of the scene.
    headlight(gv);
    %%
    % ...and make the figure visible and interact with the view.
    interact(gv);
    
    
    %% Discussion
    %
    
    %%
    % Temperature at point P: Find the node at that point using a bounding box,...
    Pid=fenode_select(fens,struct('box',bounding_box(P),...
        'inflate', 1/1000)) ;
    
    %%
    % ...  and retrieve the temperature:
    temp.values(Pid)
    %%
    % This may be compared with the analytical solution of 0.901 degrees at
    % point P. With the given mesh we are therefore within 2.5% of the
    % analytical solution.
    
end
##### SOURCE END #####
--></body></html>