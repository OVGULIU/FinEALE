classdef material_deformation_bb_transviso_triax < material_deformation_triax
    % Class that represents triaxial transversely isotropic hyper elastic material of Bonet and Burton.
    %
    % @article{
   % author = {Bonet, J. and Burton, A. J.},
   % title = {A simple orthotropic, transversely isotropic hyperelastic constitutive equation for large strain computations},
   % journal = {Computer Methods in Applied Mechanics and Engineering},
   % volume = {162},
   % number = {1-4},
   % pages = {151-164},
   % year = {1998}
% }

    properties (Access =Private)
        self.lambda =[]; 
            self.mu =[]; 
            self.alpha =[]; 
            self.beta =[]; 
            self.gamma =[]; 
    end
    
    methods
        
        function self = material_deformation_bb_transviso_triax(Parameters)
            % Constructor.
            % Parameters:
            % none
            %
            % See discussion of constructors in <a href="matlab:helpwin 'fineale/classes/Contents'">classes/Contents</a>.
            if (nargin < 1)
                Parameters =struct( [] );
            end
            self = self@material_deformation_triax(Parameters);
            %     E1 =Young's modulus in the direction of the axis of transverse isotropy (the so-called longitudinal elastic modulus)
            %     E2 =Young's modulus in the plane of transverse isotropy (the so-called transverse elastic modulus)
            %     nu12 =Poisson ratio for loading along the axis of transverse isotropy
            %     nu23 =Poisson ratio for loading in the plane orthogonal to the axis of transverse isotropy
            %     G12=Shear modulus for sheer between the axis of transverse isotropy in the plane orthogonal to it
            EA = self.property.E1;
            nu = self.property.nu23;
            GA = self.property.G12;
            E = self.property.E2;
            n =EA/E;
            m =1-nu-2*n*nu^2;
            self.lambda =E*(nu+n*nu^2)/(m*(1+nu)); 
            self.mu=E/(2*(1+nu)); 
            self.alpha=mu-GA;
            self.beta=E*nu^2*(1-nu)/(4*m*(1+nu)); 
            self.gamma=EA*(1-nu)/(8*m)-(lambda+2*mu)/8+alpha/2-beta;
        end
        
        function [out, newms] = update (self, ms, context)
            % Update material state.  Return the updated material state, and the
            % requested quantity (default is the stress).
            %   Call as:
            %     [out,newms] = update(m, ms, context)
            %  where
            %     m=material
            %     ms = material state
            %     context=structure
            %        with mandatory fields
            %           F= deformation gradient
            %        and optional fields
            %           output=type of quantity to output, and interpreted by the
            %           particular material; [] is returned when the material does not
            %           recognize the requested quantity to indicate uninitialized
            %           value.  It can be tested with isempty ().
            %              output ='Cauchy' - Cauchy stress; this is the default
            %                      when output type is not specified.
            %              output ='2ndPK' - 2nd Piola-Kirchhoff stress;
            %                  It is assumed that stress is output in 6-component vector form.
            %              output ='strain_energy'
            %   The output arguments are
            %     out=requested quantity
            %     newms=new material state; don't forget that if the update is final
            %           the material state newms must be assigned and stored.  Otherwise
            %           the material update is lost!
            %
            
            F1 = context.F;
            Id=eye(3,3);
            % Finger deformation tensor
            b=F1*F1';
            J=det(F1);
            kirch_iso = (self.mu) * (b - eye(3,3)) + (self.lambda *log(J)) * Id;
            % The transversely  isotropic model has the first basis vector as the axis of isotropy
            a=F1(:,1); % this is the vector along the fiber
            I4 =a'*a; % pseudo-invariant
            kirch_trn = 2*self.beta*(I4-1)*Id ...
                + 2*(self.alpha+2*self.beta*log(J)+2*self.gamma*(I4-1))*a*a' ...
                - self.alpha*(b*a*a'+a*(b*a)');
            if isfield(context,'output')
                switch context.output
                    case 'Cauchy'
                        out = self.stress_3x3t_to_6v((kirch_iso+kirch_trn)/J);
                    case'strain_energy'
                        out = [];%needs to be calculated
                    case '2ndPK'
                        invF1=inv(F1);
                        S = (invF1*((kirch_iso+kirch_trn))*invF1');
                        out= stress_3x3t_to_6v(self.mater,S);
                    case 'pressure'
                        out = -(sum(diag(((kirch_iso+kirch_trn)/J)))/3);
                    otherwise
                        out = stress_3x3t_to_6v(self.mater,((kirch_iso+kirch_trn)/J));
                end
            else
                out = stress;
            end
            newms = ms;
            return;
        end
        
        function D = tangent_moduli(self, context)
            % Calculate the material stiffness matrix.
            %   Call as:
            %     D = tangent_moduli(m, context)
            %   where
            %     m=material
            %    context=struct
            % with fields
            %  - mandatory
            %  - optional
            %     stiff_type=type of the stiffness,
            %        either 'Lagrangean'
            %        or 'Eulerian'
            %              requires field 'F'= current deformation gradient
            % the output arguments are
            %     D=matrix 6x6
            %
            stiff_type='Eulerian';
            if isfield(context,'stiff_type')
                stiff_type= context.stiff_type;
            end
            switch (stiff_type)
                case 'Eulerian'
                    E = self.property.E;
                    nu = self.property.nu;
                    J =det(context.F);
                    lambda = E * nu / (1 + nu) / (1 - 2*(nu));          % Lame constant #1
                    mu     = E / (2 * (1 + nu));                        % shear modulus
                    kappa  = E / 3 / (1 - 2*nu);                        % bulk modulus
                    mI = diag([1 1 1 0.5 0.5 0.5]);
                    m1     = [1 1 1 0 0 0]';
                    D = (lambda / J) * m1 * m1' + 2 * (mu - lambda*log(J))/J * mI;
                    return;
                otherwise
                    error('Cannot handle');
                    D=[]; % return non-usable value
                    return;
            end
        end
        
    end
    
end
