
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Floyd's pressure vessel</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-12-17"><meta name="DC.source" content="pub_Floyd.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Floyd's pressure vessel</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Description</a></li><li><a href="#11">Solution</a></li><li><a href="#41">Discussion</a></li></ul></div><p>Link to the  <a href="matlab:edit('pub_Floyd')">m-file</a>.</p><h2>Description<a name="2"></a></h2><p>Thick-walled pressure vessel of Araldite has an axis of symmetry and a plane of symmetry perpendicular to its axis  Therefore only half of the generating section is shown in Figure 1. The vessel is loaded by internal pressure.   Linear elasticity model is employed with  a homogeneous isotropic material (Young's modulus of 1435 psi and Poisson's ratio .49).</p><p>
<table border=0><tr><td>
<img src="../docs/pub_Floyd3.jpg" width = "20%">
<img src="../docs/pub_Floyd.jpg" width = "70%">
</td></tr>
<tr><td>Figure 1. Thick-walled pressure vessel of Araldite</td></tr>
</table>
</p><p>The structure was studied in the book by Babuska, Szabo. The authors point out that very few problems have been studied both experimentally (with photoelasticity) and analytically (with finite and boundary element methods).  For this problem, a pressure vessel with axial symmetry loaded by internal pressure (see Figure 1),  both experimental studies and numerous analytical investigations have been published.</p><p>For instance, Sussman and Bathe applied finite element analysis and observed significant oscillations of the stress when it was computed from the displacement field for serendipity eight node elements.</p><p>Brebbia and Trevelyan  used boundary element method and produced  quite convincing clean results.</p><p>References</p><div><ol><li>Sussman T, Bathe KJ (1985) STUDIES OF FINITE-ELEMENT PROCEDURES - ON MESH SELECTION. Computers &amp; Structures 21: 257-264.</li><li>Brebbia CA, Trevelyan J (1986) ON THE ACCURACY AND CONVERGENCE OF BOUNDARY ELEMENT RESULTS FOR THE FLOYD PRESSURE-VESSEL PROBLEM. Computers &amp; Structures 24: 513-516.</li><li>Szabo BA (1991) ON RELIABILITY IN FINITE-ELEMENT COMPUTATIONS. Computers &amp; Structures 39: 729-734.</li></ol></div><p>The book describes the goal as "Compute the location, orientation, and magnitude of the largest principal stress and give evidence that the computed values are accurate to within 5% relative error".</p><h2>Solution<a name="11"></a></h2><pre class="codeinput"><span class="keyword">function</span>  pub_Floyd
</pre><pre class="codeinput">    u=  physical_units_struct;
</pre><p>The material parameters are taken from the Szabo  (1991) paper.</p><pre class="codeinput">    E= 1435*u.PSI;<span class="comment">%</span>
    nu=0.49;
</pre><p>Geometrical dimensions.</p><pre class="codeinput">    R1= 6*u.IN;<span class="comment">%</span>
    Rf=0.15*u.IN;<span class="comment">%</span>
    R2=R1-0.6*u.IN;<span class="comment">%</span>
    L1=3.15*u.IN;<span class="comment">%</span>
    L2=1.5*u.IN;<span class="comment">%</span>
    targetY=1.568*u.IN;<span class="comment">% Location of the stress output line</span>
</pre><p>Magnitude of the pressure applied on the interior surface of the vessel.</p><pre class="codeinput">    Pressure=2.61*u.PSI;
</pre><p>The mesh is generated using mesh control that adjusts the gradation so that near the fillet between the and the wall  is highly refined.  Away from this high-concentration area the mesh is generated rather coarse.</p><pre class="codeinput">    mesh_size=R1/(2^3);
    [fens,fes,groups,edge_fes,edge_groups]=targe2_mesher({<span class="keyword">...</span>
        [<span class="string">'curve 1 line '</span> num2str([0,0]) <span class="string">' '</span> num2str([R1,0]) ],<span class="keyword">...</span>
        [<span class="string">'curve 2 line '</span> num2str([R1,0]) <span class="string">' '</span> num2str([R1,L1]) ],<span class="keyword">...</span>
        [<span class="string">'curve 3 line '</span> num2str([R1,L1]) <span class="string">' '</span> num2str([R2,L1]) ],<span class="keyword">...</span>
        [<span class="string">'curve 4 line '</span> num2str([R2,L1]) <span class="string">' '</span> num2str([R2,L2+Rf]) ],<span class="keyword">...</span>
        [<span class="string">'curve 5 arc '</span> num2str([R2,L2+Rf]) <span class="string">' '</span> num2str([R2-Rf,L2])<span class="keyword">...</span>
        <span class="string">' center '</span> num2str([R2-Rf,L2+Rf]) ],<span class="keyword">...</span>
        [<span class="string">'curve 6 line '</span> num2str([R2-Rf,L2]) <span class="string">' '</span> num2str([0,L2]) ],<span class="keyword">...</span>
        [<span class="string">'curve 7 line '</span> num2str([0,L2]) <span class="string">' '</span> num2str([0,0]) ],<span class="keyword">...</span>
        [<span class="string">'subregion 1  property 1 boundary 1 2 3 4 5 6 7'</span>],<span class="keyword">...</span>
        [<span class="string">'m-ctl-point constant '</span> num2str(mesh_size)],<span class="keyword">...</span>
        [<span class="string">'m-ctl-point 1 xy '</span> num2str([R2-Rf,L2+Rf]) <span class="keyword">...</span>
        <span class="string">' near '</span> num2str(mesh_size/40000) <span class="string">' influence '</span> num2str(Rf/100)],<span class="keyword">...</span>
        }, 1.0, struct(<span class="string">'axisymm'</span>,true,<span class="string">'quadratic'</span>,true));
    <span class="comment">%         drawmesh({fens,fes},'fes','facecolor','red');  view(2); return</span>
</pre><p>Compose the model data.</p><pre class="codeinput">    clear <span class="string">model_data</span>
    model_data.fens =fens;
</pre><p>Note that we are setting the "axial symmetry" flag.</p><pre class="codeinput">    clear <span class="string">region</span>
    region.E =E;
    region.nu =nu;
    region.reduction =<span class="string">'axisymm'</span>;
    region.fes= fes;
    region.integration_rule = tri_rule (struct(<span class="string">'npts'</span>, 3));
    model_data.region{1} =region;
</pre><p>The essential boundary conditions are applied on the plane of symmetry ...</p><pre class="codeinput">    clear <span class="string">essential</span> <span class="comment">% the symmetry plane</span>
    essential.component= 2;
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,struct(<span class="string">'box'</span>,[0 R1 L1 L1],<span class="string">'inflate'</span>,L1/1000));
    model_data.boundary_conditions.essential{1} = essential;
</pre><p>...  And the axis of symmetry.</p><pre class="codeinput">    clear <span class="string">essential</span> <span class="comment">% the axis of symmetry</span>
    essential.component= 1;
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,struct(<span class="string">'box'</span>,[0 0 0 L1+L2],<span class="string">'inflate'</span>,L1/1000));
    model_data.boundary_conditions.essential{2} = essential;
</pre><p>Three separate traction  definitions are provided.  One on the vertical surface:</p><pre class="codeinput">    clear <span class="string">traction</span>
    traction.fes= subset(edge_fes,edge_groups{4});
    traction.integration_rule = gauss_rule (struct(<span class="string">'dim'</span>, 1,  <span class="string">'order'</span>, 2));
    traction.traction = [Pressure;0];
    model_data.boundary_conditions.traction{1} = traction;
</pre><p>One on the surface of the fillet.</p><pre class="codeinput">    clear <span class="string">traction</span>
    traction.fes= subset(edge_fes,edge_groups{5});
    traction.integration_rule = gauss_rule (struct(<span class="string">'dim'</span>, 1,  <span class="string">'order'</span>, 2));
    traction.traction = @(x) (Pressure*(x-[R2-Rf,L2+Rf])'/norm((x-[R2-Rf,L2+Rf])));
    model_data.boundary_conditions.traction{2} = traction;
</pre><p>And the last one on the surface of the bottom.</p><pre class="codeinput">    clear <span class="string">traction</span>
    traction.fes= subset(edge_fes,edge_groups{6});
    traction.integration_rule = gauss_rule (struct(<span class="string">'dim'</span>, 1,  <span class="string">'order'</span>, 2));
    traction.traction = [0;-Pressure];
    model_data.boundary_conditions.traction{3} = traction;
</pre><p>Call the static solver.</p><pre class="codeinput">    model_data =deformation_linear_statics(model_data);
</pre><p>The deformed shape is shown with the color-coded hoop stress (#3).</p><pre class="codeinput">    model_data.postprocessing.u_scale= 5;
    model_data.postprocessing.stress_component=3;
    model_data.postprocessing.stress_range = 10*[-Pressure,+Pressure];
    model_data.postprocessing.use_spr=true;
    model_data=deformation_plot_stress(model_data);
    view (2); ;
</pre><img vspace="5" hspace="5" src="pub_Floyd_01.png" alt=""> <p>Now we will calculate the principal stresses along the output line indicated in Figure 1. The calculation here is based on postprocessed stress results.  We use the super convergent patch recovery to compute nodal stress fields, and then we calculate the principal stresses from the continuous nodal stress field.</p><p>The principal stress values along the output line will be calculated for each output point by interpolating  the nodal field. We will re-triangulate the nodes  by splitting each quadratic triangle into three linear triangles (only for the interpolation purposes). The output point will then be located within a particular triangle, and the value at the output point will be interpolated from the three corners of the triangle.</p><p>We begin by defining the re-triangulation of the mesh.  The triangles are  defined using the connectivity of each quadratic triangle to split it into four subtriangles.</p><pre class="codeinput">    tri=[fes.conn(:,[1,4,6]);fes.conn(:,[4,2,5]);fes.conn(:,[3,6,5]);fes.conn(:,[4,5,6]);];
</pre><p>The output points are generated along the output line.</p><pre class="codeinput">    xi=[linspace(5.373*u.IN,6.0*u.IN,55)',zeros(55,1)+targetY];
</pre><p>The four components of the Cauchy stress tensor  that are present in the axially symmetric model are computed by the super convergent patch recovery.</p><p>First we calculate the four nodal fields, one for each component.</p><pre class="codeinput">    fld1 = field_from_integration_points_spr(model_data.region{1}.femm, <span class="keyword">...</span>
        model_data.geom, model_data.u, [], <span class="string">'Cauchy'</span>,1);
    fld2 = field_from_integration_points_spr(model_data.region{1}.femm, <span class="keyword">...</span>
        model_data.geom, model_data.u, [], <span class="string">'Cauchy'</span>,2);
    fld3 = field_from_integration_points_spr(model_data.region{1}.femm, <span class="keyword">...</span>
        model_data.geom, model_data.u, [], <span class="string">'Cauchy'</span>,3);
    fld4 = field_from_integration_points_spr(model_data.region{1}.femm, <span class="keyword">...</span>
        model_data.geom, model_data.u, [], <span class="string">'Cauchy'</span>,4);
</pre><p>The stresses are now processed to extract the principal stresses.  Since the cited references refer only to the principal-stress components in the plane of the generating section, we will make sure we compute only the in-plane principal stresses.</p><p>We will need to loop over all computed nodal stresses, perform the eigenvalue problem solution, and assign the principal stresses at  the nodes.</p><pre class="codeinput">    stresses = [fld1.values,fld2.values,fld3.values,fld4.values];
    Ps=zeros(size(stresses,1),3);<span class="comment">%</span>
    <span class="keyword">for</span> q= 1:size(stresses,1)
</pre><p>Note that the eigenvalue problem is two-dimensional: in the plane of the generating section we have only three stress components.</p><pre class="codeinput">        [V,D]=eig(stress_3v_to_2x2t (material_deformation,stresses(q,[1, 2, 4])));
        sD=sort(diag(D),<span class="string">'descend'</span>);
        Ps(q,1:2)=sD; Ps(q,3)=stresses(q,3);
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><p>The computed principal stresses at the nodes are now interpolated to the points along the output line. The utility <tt>simplex_grid_interpolation</tt> performs the location of the output points within the triangles and the interpolation from the nodes.</p><p>This is the distribution of the first (maximum) in-plane principal stress along the   line of stress output.</p><pre class="codeinput">    fxi = simplex_grid_interpolation(model_data.geom.values,Ps(:,1),tri,xi);
    figure;
    plot(xi(:,1)/u.IN,fxi/u.PSI,<span class="string">'rx'</span>, <span class="string">'linewidth'</span>,3)
    set(gca,<span class="string">'xlim'</span>,[min(xi(:,1)),max(xi(:,1))]/u.IN)
    grid <span class="string">on</span>
    labels(  <span class="string">'Distance from the axis of symmetry [in]'</span> , <span class="string">'First in-plane principal stress [psi]'</span>)
</pre><img vspace="5" hspace="5" src="pub_Floyd_02.png" alt=""> <p>This is the distribution of the second (minimum) in-plane principal stress along the   line of stress output.</p><pre class="codeinput">    fxi = simplex_grid_interpolation(model_data.geom.values,Ps(:,2),tri,xi);
    figure;
    plot(xi(:,1)/u.IN,fxi/u.PSI,<span class="string">'rx'</span>, <span class="string">'linewidth'</span>,3)
    set(gca,<span class="string">'xlim'</span>,[min(xi(:,1)),max(xi(:,1))]/u.IN)
    grid <span class="string">on</span>
    labels(  <span class="string">'Distance from the axis of symmetry [in]'</span> , <span class="string">'Second in-plane principal stress [psi]'</span>)
</pre><img vspace="5" hspace="5" src="pub_Floyd_03.png" alt=""> <p>The above graphs compare favorably with results produced by the references.  For instance as shown in Figure 2:</p><p>
<table border=0><tr><td>
<img src="../docs/pub_Floyd_max_2-D.jpg" width = "40%">
<img src="../docs/pub_Floyd_min_2-D.jpg" width = "40%">
</td></tr>
<tr><td>Figure 2. Maximum and minimum principal in-plane stress from Brebbia and Trevelyan (1986)</td></tr>
</table>
</p><p>An alternative procedure to calculate the principal stresses is to use the <tt>field_from_integration_points_spr</tt> method.    In the present case the hoop-direction principal stress is always the intermediate principal stress along the output line.  (Perhaps not elsewhere!) Therefore, requesting the third principal stress produces the same plot of the minimum principal stress as above.</p><pre class="codeinput">    stressf = field_from_integration_points_spr (model_data.region{1}.femm, <span class="keyword">...</span>
        model_data.geom, model_data.u, [], <span class="string">'princCauchy'</span>,3, <span class="keyword">...</span>
        struct(<span class="string">'outputRm'</span>,eye(3)));
    fxi = simplex_grid_interpolation(model_data.geom.values,stressf.values,tri,xi);
    figure;
    plot(xi(:,1)/u.IN,fxi/u.PSI,<span class="string">'k+'</span>, <span class="string">'linewidth'</span>,3)
    set(gca,<span class="string">'xlim'</span>,[min(xi(:,1)),max(xi(:,1))]/u.IN)
    grid <span class="string">on</span>
    labels(  <span class="string">'Distance from the axis of symmetry [in]'</span> , <span class="string">'Minimum principal stress (3-D!) [psi]'</span>)
</pre><img vspace="5" hspace="5" src="pub_Floyd_04.png" alt=""> <h2>Discussion<a name="41"></a></h2><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Floyd's pressure vessel
%

%%
% Link to the  <matlab:edit('pub_Floyd') m-file>.

%% Description

%%
% Thick-walled pressure vessel of Araldite has an axis of symmetry and a
% plane of symmetry perpendicular to its axis  Therefore only half of the
% generating section is shown in Figure 1. The vessel is loaded by internal
% pressure.   Linear elasticity model is employed with  a homogeneous
% isotropic material (Young's modulus of 1435 psi and Poisson's ratio .49).

%%
%
% <html>
% <table border=0><tr><td>
% <img src="../docs/pub_Floyd3.jpg" width = "20%">
% <img src="../docs/pub_Floyd.jpg" width = "70%">
% </td></tr>
% <tr><td>Figure 1. Thick-walled pressure vessel of Araldite</td></tr>
% </table>
% </html>

%%
%
% The structure was studied in the book by Babuska, Szabo. The authors
% point out that very few problems have been studied both experimentally
% (with photoelasticity) and analytically (with finite and boundary element
% methods).  For this problem, a pressure vessel with axial symmetry loaded
% by internal pressure (see Figure 1),  both experimental studies and
% numerous analytical investigations have been published.
%

%%
% For instance, Sussman and Bathe applied finite element analysis and
% observed significant oscillations of the stress when it was computed from
% the displacement field for serendipity eight node elements.
%%
% Brebbia and Trevelyan  used boundary element method and produced  quite
% convincing clean results.

%%
% References
%%
% # Sussman T, Bathe KJ (1985) STUDIES OF FINITE-ELEMENT PROCEDURES - ON
% MESH SELECTION. Computers & Structures 21: 257-264.
% # Brebbia CA,
% Trevelyan J (1986) ON THE ACCURACY AND CONVERGENCE OF BOUNDARY ELEMENT
% RESULTS FOR THE FLOYD PRESSURE-VESSEL PROBLEM. Computers & Structures 24:
% 513-516.
% # Szabo BA (1991) ON RELIABILITY IN FINITE-ELEMENT COMPUTATIONS. Computers & Structures 39: 729-734.

%%
% The book describes the goal as "Compute the location, orientation, and
% magnitude of the largest principal stress and give evidence that the
% computed values are accurate to within 5% relative error".

%% Solution
%
function  pub_Floyd
    u=  physical_units_struct;
    
    %%
    % The material parameters are taken from the Szabo  (1991) paper.
    E= 1435*u.PSI;%
    nu=0.49;
    
    %%
    % Geometrical dimensions.
    R1= 6*u.IN;%
    Rf=0.15*u.IN;%
    R2=R1-0.6*u.IN;%
    L1=3.15*u.IN;%
    L2=1.5*u.IN;%
    targetY=1.568*u.IN;% Location of the stress output line
    
    %%
    % Magnitude of the pressure applied on the interior surface of the vessel.
    Pressure=2.61*u.PSI;
    
    
    
    %%
    % The mesh is generated using mesh control that adjusts the gradation so
    % that near the fillet between the and the wall  is highly refined.  Away
    % from this high-concentration area the mesh is generated rather coarse.
    mesh_size=R1/(2^3);
    [fens,fes,groups,edge_fes,edge_groups]=targe2_mesher({...
        ['curve 1 line ' num2str([0,0]) ' ' num2str([R1,0]) ],...
        ['curve 2 line ' num2str([R1,0]) ' ' num2str([R1,L1]) ],...
        ['curve 3 line ' num2str([R1,L1]) ' ' num2str([R2,L1]) ],...
        ['curve 4 line ' num2str([R2,L1]) ' ' num2str([R2,L2+Rf]) ],...
        ['curve 5 arc ' num2str([R2,L2+Rf]) ' ' num2str([R2-Rf,L2])...
        ' center ' num2str([R2-Rf,L2+Rf]) ],...
        ['curve 6 line ' num2str([R2-Rf,L2]) ' ' num2str([0,L2]) ],...
        ['curve 7 line ' num2str([0,L2]) ' ' num2str([0,0]) ],...
        ['subregion 1  property 1 boundary 1 2 3 4 5 6 7'],...
        ['m-ctl-point constant ' num2str(mesh_size)],...
        ['m-ctl-point 1 xy ' num2str([R2-Rf,L2+Rf]) ...
        ' near ' num2str(mesh_size/40000) ' influence ' num2str(Rf/100)],...
        }, 1.0, struct('axisymm',true,'quadratic',true));
    %         drawmesh({fens,fes},'fes','facecolor','red');  view(2); return
    
    
    %%
    % Compose the model data.
    clear model_data
    model_data.fens =fens;
    
    %%
    % Note that we are setting the "axial symmetry" flag.
    clear region
    region.E =E;
    region.nu =nu;
    region.reduction ='axisymm';
    region.fes= fes;
    region.integration_rule = tri_rule (struct('npts', 3));
    model_data.region{1} =region;
    
    %%
    % The essential boundary conditions are applied on the plane of symmetry ...
    clear essential % the symmetry plane
    essential.component= 2;
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,struct('box',[0 R1 L1 L1],'inflate',L1/1000));
    model_data.boundary_conditions.essential{1} = essential;
    
    %%
    % ...  And the axis of symmetry.
    clear essential % the axis of symmetry
    essential.component= 1;
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,struct('box',[0 0 0 L1+L2],'inflate',L1/1000));
    model_data.boundary_conditions.essential{2} = essential;
    
    %%
    % Three separate traction  definitions are provided.  One on the vertical surface:
    clear traction
    traction.fes= subset(edge_fes,edge_groups{4});
    traction.integration_rule = gauss_rule (struct('dim', 1,  'order', 2));
    traction.traction = [Pressure;0];
    model_data.boundary_conditions.traction{1} = traction;
    
    %%
    % One on the surface of the fillet.
    clear traction
    traction.fes= subset(edge_fes,edge_groups{5});
    traction.integration_rule = gauss_rule (struct('dim', 1,  'order', 2));
    traction.traction = @(x) (Pressure*(x-[R2-Rf,L2+Rf])'/norm((x-[R2-Rf,L2+Rf])));
    model_data.boundary_conditions.traction{2} = traction;
    
    %%
    % And the last one on the surface of the bottom.
    clear traction
    traction.fes= subset(edge_fes,edge_groups{6});
    traction.integration_rule = gauss_rule (struct('dim', 1,  'order', 2));
    traction.traction = [0;-Pressure];
    model_data.boundary_conditions.traction{3} = traction;
    
    
    %%
    % Call the static solver.
    model_data =deformation_linear_statics(model_data);
    
    
    %%
    % The deformed shape is shown with the color-coded hoop stress (#3).
    model_data.postprocessing.u_scale= 5;
    model_data.postprocessing.stress_component=3;
    model_data.postprocessing.stress_range = 10*[-Pressure,+Pressure];
    model_data.postprocessing.use_spr=true;
    model_data=deformation_plot_stress(model_data);
    view (2); ;
    
    %%
    % Now we will calculate the principal stresses along the output line
    % indicated in Figure 1.
    % The calculation here is based on postprocessed stress results.  We
    % use the super convergent patch recovery to compute nodal stress
    % fields, and then we calculate the principal stresses from the
    % continuous nodal stress field.
    
    %%
    % The principal stress values along the output line will be calculated
    % for each output point by interpolating  the nodal field. We will
    % re-triangulate the nodes  by splitting each quadratic triangle into
    % three linear triangles (only for the interpolation purposes). The
    % output point will then be located within a particular triangle, and
    % the value at the output point will be interpolated from the three
    % corners of the triangle.
%% 
% We begin by defining the re-triangulation of the mesh.  The triangles
% are  defined using the connectivity of each quadratic triangle to split
% it into four subtriangles.
    tri=[fes.conn(:,[1,4,6]);fes.conn(:,[4,2,5]);fes.conn(:,[3,6,5]);fes.conn(:,[4,5,6]);];
%% 
% The output points are generated along the output line.
    xi=[linspace(5.373*u.IN,6.0*u.IN,55)',zeros(55,1)+targetY];
    
%% 
% The four components of the Cauchy stress tensor  that are present in the
% axially symmetric model are computed by the super convergent patch
% recovery.
%% 
% First we calculate the four nodal fields, one for each component.
    fld1 = field_from_integration_points_spr(model_data.region{1}.femm, ...
        model_data.geom, model_data.u, [], 'Cauchy',1);
    fld2 = field_from_integration_points_spr(model_data.region{1}.femm, ...
        model_data.geom, model_data.u, [], 'Cauchy',2);
    fld3 = field_from_integration_points_spr(model_data.region{1}.femm, ...
        model_data.geom, model_data.u, [], 'Cauchy',3);
    fld4 = field_from_integration_points_spr(model_data.region{1}.femm, ...
        model_data.geom, model_data.u, [], 'Cauchy',4);
    

%% 
% The stresses are now processed to extract the principal stresses.  Since
% the cited references refer only to the principal-stress components in the
% plane of the generating section, we will make sure we compute only the
% in-plane principal stresses.

%% 
% We will need to loop over all computed nodal stresses, perform the
% eigenvalue problem solution, and assign the principal stresses at  the
% nodes.
    stresses = [fld1.values,fld2.values,fld3.values,fld4.values];
    Ps=zeros(size(stresses,1),3);%
    for q= 1:size(stresses,1)
%% 
% Note that the eigenvalue problem is two-dimensional: in the plane of the
% generating section we have only three stress components.
        [V,D]=eig(stress_3v_to_2x2t (material_deformation,stresses(q,[1, 2, 4])));
        sD=sort(diag(D),'descend');
        Ps(q,1:2)=sD; Ps(q,3)=stresses(q,3);
    end
%% 
% The computed principal stresses at the nodes are now interpolated to the
% points along the output line. The utility |simplex_grid_interpolation|
% performs the location of the output points within the triangles and the
% interpolation from the nodes.
    %%
    % This is the distribution of the first (maximum) in-plane principal
    % stress along the   line of stress output.
    fxi = simplex_grid_interpolation(model_data.geom.values,Ps(:,1),tri,xi);
    figure;
    plot(xi(:,1)/u.IN,fxi/u.PSI,'rx', 'linewidth',3)
    set(gca,'xlim',[min(xi(:,1)),max(xi(:,1))]/u.IN)
    grid on
    labels(  'Distance from the axis of symmetry [in]' , 'First in-plane principal stress [psi]')
    
    %%
    % This is the distribution of the second (minimum) in-plane principal
    % stress along the   line of stress output.
    fxi = simplex_grid_interpolation(model_data.geom.values,Ps(:,2),tri,xi);
    figure;
    plot(xi(:,1)/u.IN,fxi/u.PSI,'rx', 'linewidth',3)
    set(gca,'xlim',[min(xi(:,1)),max(xi(:,1))]/u.IN)
    grid on
    labels(  'Distance from the axis of symmetry [in]' , 'Second in-plane principal stress [psi]')
    
    %%
    %
    % The above graphs compare favorably with results produced by the
    % references.  For instance as shown in Figure 2:
    %
    % <html>
    % <table border=0><tr><td>
    % <img src="../docs/pub_Floyd_max_2-D.jpg" width = "40%">
    % <img src="../docs/pub_Floyd_min_2-D.jpg" width = "40%">
    % </td></tr>
    % <tr><td>Figure 2. Maximum and minimum principal in-plane stress from Brebbia and Trevelyan (1986)</td></tr>
    % </table>
    % </html>
    
    %%
    % An alternative procedure to calculate the principal stresses is to
    % use the |field_from_integration_points_spr| method.    In the present
    % case the hoop-direction principal stress is always the intermediate
    % principal stress along the output line.  (Perhaps not elsewhere!)
    % Therefore, requesting the third principal stress produces the same
    % plot of the minimum principal stress as above.
    stressf = field_from_integration_points_spr (model_data.region{1}.femm, ...
        model_data.geom, model_data.u, [], 'princCauchy',3, ...
        struct('outputRm',eye(3)));
    fxi = simplex_grid_interpolation(model_data.geom.values,stressf.values,tri,xi);
    figure;
    plot(xi(:,1)/u.IN,fxi/u.PSI,'k+', 'linewidth',3)
    set(gca,'xlim',[min(xi(:,1)),max(xi(:,1))]/u.IN)
    grid on
    labels(  'Distance from the axis of symmetry [in]' , 'Minimum principal stress (3-D!) [psi]')
    
    %% Discussion
    %
end

##### SOURCE END #####
--></body></html>