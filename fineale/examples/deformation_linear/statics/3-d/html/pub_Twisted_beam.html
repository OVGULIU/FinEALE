
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Twisted beam  benchmark</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-12-20"><meta name="DC.source" content="pub_Twisted_beam.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Twisted beam  benchmark</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Description</a></li><li><a href="#8">Solution</a></li></ul></div><p>Link to the  <a href="matlab:edit('pub_Twisted_beam')">m-file</a>.</p><h2>Description<a name="2"></a></h2><p>The initially twisted cantilever beam is one of the standard test problems for verifying  finite element accuracy [1]. The beam is clamped at one end and loaded either with unit in-plane or unit out-of-plane force at the other. The centroidal axis of the beam is straight at the undeformed  configuration, while its cross-sections are twisted about the centroidal axis from 0 at the clamped end to pi/2 at the free end. As discussed  by Zupan and Saje the geometry is created by linearly varying the twist angle (rotation of the cross-section), which results in curvilinear edges of the undeformed beam.</p><p>The twisted beam is discretized with solid elements. Different kinds of elements are employed  in order to illustrate the relative accuracy.</p><p>
<table border=0><tr><td>
<img src="../docs/pub_Twisted_beam.png" width="35%">
</td></tr>
<tr><td>Figure 1. Definition of the geometry of the thick elliptical plate</td></tr>
</table>
</p><p>References:</p><div><ol><li>Macneal RH, Harder RL (1985) A proposed standard set of problems to test finite element accuracy. Finite Elements in Analysis and Design 1: 3-20.</li><li>Zupan D, Saje M (2004) On "A proposed standard set of problems to test finite element accuracy": the twisted beam. Finite Elements in Analysis and Design 40: 1445-1451.</li></ol></div><h2>Solution<a name="8"></a></h2><pre class="codeinput"><span class="keyword">function</span>  pub_Twisted_beam
</pre><p>The material parameters and dimensions are in consistent units.</p><pre class="codeinput">E=0.29e8;<span class="comment">% Young's modulus</span>
nu=0.22;<span class="comment">% Poisson's ratio</span>
W=1.1;<span class="comment">%  width of the cross-section</span>
L=12;<span class="comment">% length of the beam</span>
t= 0.32;<span class="comment">% thickness of the cross-section</span>
tolerance  =0.001*t;<span class="comment">% geometrical tolerance</span>
</pre><p>The beam is loaded with unit force at the free cross-section.  Therefore the traction component is  1.0 divided by the cross-sectional area.</p><pre class="codeinput">p=  1/W/t;<span class="comment">%</span>
</pre><p>For the load in the the  Z direction Macneal and Harder list the deflection in the direction of the load of 5.424e-3 units.  The deflection used here was determined by running a series of simulations and extrapolating to the limit.</p><pre class="codeinput">load{3}.traction=[0;0;p];
load{3}.utipex=0.005424534868469;
</pre><p>For the load in the the  Y direction  Macneal and Harder list the deflection in the direction of the load of 1.754e-3 units.  The deflection used here was determined by running a series of simulations and extrapolating to the limit.</p><pre class="codeinput">load{2}.traction=[0;p;0];
load{2}.utipex=0.001753248285256;
</pre><p>The usual 3-D material property  and triaxial material  object:</p><pre class="codeinput">prop=property_deformation_linear_iso(struct(<span class="string">'E'</span>,E,<span class="string">'nu'</span>,nu));
mater = material_deformation_linear_triax (struct(<span class="string">'property'</span>,prop ));
</pre><p>The coarsest mesh will have two elements lengthwise and one element across the width and across the thickness.</p><pre class="codeinput">nl=2; nt=1; nw=1;<span class="comment">% number of elements employed</span>
</pre><p>For each combination of element type and load direction and  mesh refinement  we will execute the simulation using this function.</p><pre class="codeinput">    <span class="keyword">function</span> [utip,nfreedofs] = simulate(<span class="keyword">...</span>
            mf, <span class="keyword">...</span><span class="comment">% mesh function handle</span>
            femmf, <span class="keyword">...</span><span class="comment">% finite element model machine function handle</span>
            surface_integration_rule,<span class="keyword">...</span><span class="comment">% rule to integrate the traction loads</span>
            load_dir,<span class="keyword">...</span><span class="comment">% load direction (2 or 3)</span>
            ref<span class="keyword">...</span><span class="comment">% refinement factor (&gt;=1)</span>
            )
        <span class="comment">% Create the mesh and initialize the geometry.</span>
        [fens,fes]= mf(L,W,t, nl*ref,nw*ref,nt*ref);
        <span class="comment">% Now shape  the twisted beam by rotating each cross-section by an</span>
        <span class="comment">% appropriate angle about the axis of the beam.</span>
        xyz=fens.xyz;
        <span class="keyword">for</span> i=1:count (fens)
            a=xyz(i,1)/L*(pi/2); y=xyz(i,2)-(W/2); z=xyz(i,3)-(t/2);
            xyz(i,:)=[xyz(i,1),y*cos(a)-z*sin(a),y*sin(a)+z*cos(a)];
        <span class="keyword">end</span>
        fens.xyz=xyz;
        <span class="comment">% Compose the model data</span>
        clear <span class="string">model_data</span>
        model_data.fens =fens;
        clear <span class="string">region</span>
        region.fes= fes;
        region.femm= femmf(fes);
        model_data.region{1} =region;
        <span class="comment">%         The clamped end: all displacements  fixed.</span>
        clear <span class="string">essential</span>
        essential.component= [1,2,3];
        essential.fixed_value= 0;
        essential.node_list = fenode_select (fens,<span class="keyword">...</span>
            struct (<span class="string">'box'</span>,[0 0 -inf inf -inf inf],<span class="string">'inflate'</span>,tolerance));
        model_data.boundary_conditions.essential{1} = essential;
        <span class="comment">% The free end cross-section is loaded with the force.</span>
        clear <span class="string">traction</span>
        bdry_fes = mesh_boundary(fes, []);
        bcl = fe_select(fens, bdry_fes, <span class="keyword">...</span>
            struct (<span class="string">'box'</span>,[L L -inf inf -inf inf],<span class="string">'inflate'</span>,tolerance));
        traction.fes =subset(bdry_fes,bcl);;
        traction.traction= load{load_dir}.traction;
        traction.integration_rule =surface_integration_rule;
        model_data.boundary_conditions.traction{1} = traction;
        <span class="comment">% Solve</span>
        model_data =deformation_linear_statics(model_data);
        <span class="comment">% Collect  the displacements of all the nodes at the free end</span>
        enl=connected_nodes(model_data.boundary_conditions.traction{1}.fes);
        uv=gather_values (model_data.u,enl);
        <span class="comment">% and the "tip" displacement will be the mean of those</span>
        <span class="comment">% displacements</span>
        utip= mean(uv(:,load_dir));
        nfreedofs  =model_data.u.nfreedofs;
    <span class="keyword">end</span>
</pre><p>The response to the loads in different directions varies, but in the interest of brevity we will  consider only the direction of axis Y.</p><pre class="codeinput">load_dir=2;
</pre><p>The first element we consider is the quadratic tetrahedron.</p><pre class="codeinput">description =<span class="string">'T10'</span>;<span class="comment">% tetrahedron</span>
mf =@T10_block;
femmf =@(fes)femm_deformation_linear(struct(<span class="string">'fes'</span>,fes,<span class="string">'material'</span>,mater,<span class="keyword">...</span>
    <span class="string">'integration_rule'</span>,tet_rule(struct(<span class="string">'npts'</span>,4))));
surface_integration_rule=tri_rule(struct(<span class="string">'npts'</span>,3));
ref=1;
[utip,nfreedofs] = <span class="keyword">...</span>
    simulate(mf,femmf,surface_integration_rule,load_dir,ref);
disp ([<span class="string">'%Normalized displacement ='</span> num2str(utip/load{load_dir}.utipex)])
</pre><pre class="codeoutput">%Normalized displacement =0.47577
</pre><p>The displacement  is just 50% of the target value, but the mesh is admittedly very  coarse (just two elements along the length).</p><pre class="codeinput">ref=2;
[utip,nfreedofs] = <span class="keyword">...</span>
    simulate(mf,femmf,surface_integration_rule,load_dir,ref);
disp ([<span class="string">'%Normalized displacement ='</span> num2str(utip/load{load_dir}.utipex)])
</pre><pre class="codeoutput">%Normalized displacement =0.89115
</pre><p>In order to appreciate  the convergence of this model we will execute the simulation in a loop and plot the results.</p><pre class="codeinput"><span class="keyword">for</span> ref=1:4
    [utip(ref),nfreedofs(ref)] = <span class="keyword">...</span>
        simulate(mf,femmf,surface_integration_rule,load_dir,ref);
<span class="keyword">end</span>
</pre><p>The normalized true error is plotted on a log log scale:</p><pre class="codeinput">loglog(nfreedofs,abs(utip-load{load_dir}.utipex)/load{load_dir}.utipex,<span class="keyword">...</span>
    <span class="string">'k^--'</span>);
add_to_legend(description);
labels( <span class="string">'Number of degrees of freedom'</span>, <span class="keyword">...</span>
    <span class="string">'Normalized true error of the deflection'</span>);
</pre><img vspace="5" hspace="5" src="pub_Twisted_beam_01.png" alt=""> <p>How will a different element  compare with the quadratic tetrahedron? Here is the  20-node serendipity hexahedron:</p><pre class="codeinput">description =<span class="string">'H20R'</span>;
mf =@H20_block;
femmf =@(fes)femm_deformation_linear(struct(<span class="string">'fes'</span>,fes, <span class="string">'material'</span>,mater,<span class="keyword">...</span>
    <span class="string">'integration_rule'</span>,gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,2))));
surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,2));
<span class="keyword">for</span> ref=1:4
    [utip(ref),nfreedofs(ref)] = <span class="keyword">...</span>
        simulate(mf,femmf,surface_integration_rule,load_dir,ref);
<span class="keyword">end</span>
hold <span class="string">on</span>
loglog(nfreedofs,abs(utip-load{load_dir}.utipex)/load{load_dir}.utipex,<span class="keyword">...</span>
    <span class="string">'ro--'</span>);
add_to_legend(description);
</pre><img vspace="5" hspace="5" src="pub_Twisted_beam_02.png" alt=""> <p>For comparison we show the performance of the basic isoparametric eight node hexahedron.</p><pre class="codeinput">description =<span class="string">'H8'</span>;
mf =@H8_block;
femmf =@(fes)femm_deformation_linear(struct(<span class="string">'fes'</span>,fes, <span class="string">'material'</span>,mater,<span class="keyword">...</span>
    <span class="string">'integration_rule'</span>,gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,2))));
surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,2));
<span class="keyword">for</span> ref=1:6
    [utip(ref),nfreedofs(ref)] = <span class="keyword">...</span>
        simulate(mf,femmf,surface_integration_rule,load_dir,ref);
<span class="keyword">end</span>
hold <span class="string">on</span>
loglog(nfreedofs,abs(utip-load{load_dir}.utipex)/load{load_dir}.utipex,<span class="keyword">...</span>
    <span class="string">'md--'</span>);
add_to_legend(description);
</pre><img vspace="5" hspace="5" src="pub_Twisted_beam_03.png" alt=""> <p>It is rather a sorry sight, the bending accuracy of the H8 hexahedron is dismal. It may be improved markedly using yet again the device of selective reduced integration.  This time the shear response is going to be under-integrated.</p><pre class="codeinput">description =<span class="string">'H8-SRI'</span>;
mf =@H8_block;
femmf =@(fes)femm_deformation_linear_sri(struct(<span class="string">'fes'</span>,fes, <span class="string">'material'</span>,mater,<span class="keyword">...</span>
    <span class="string">'integration_rule_volumetric'</span>,gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,2)),<span class="keyword">...</span>
    <span class="string">'integration_rule_deviatoric'</span>,gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,1))));
surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,2));
<span class="keyword">for</span> ref=1:6
    [utip(ref),nfreedofs(ref)] = <span class="keyword">...</span>
        simulate(mf,femmf,surface_integration_rule,load_dir,ref);
<span class="keyword">end</span>
hold <span class="string">on</span>
loglog(nfreedofs,abs(utip-load{load_dir}.utipex)/load{load_dir}.utipex,<span class="keyword">...</span>
    <span class="string">'md-'</span>);
add_to_legend(description);
</pre><img vspace="5" hspace="5" src="pub_Twisted_beam_04.png" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Twisted beam  benchmark
%

%%
% Link to the  <matlab:edit('pub_Twisted_beam') m-file>.
%

%% Description
%
%%
%
% The initially twisted cantilever beam is one of the standard test
% problems for verifying  finite element accuracy [1]. The beam is clamped
% at one end and loaded either with unit in-plane or unit out-of-plane
% force at the other. The centroidal axis of the beam is straight at the
% undeformed  configuration, while its cross-sections are twisted about the
% centroidal axis from 0 at the clamped end to pi/2 at the free end. As
% discussed  by Zupan and Saje the geometry is created by linearly varying
% the twist angle (rotation of the cross-section), which results in
% curvilinear edges of the undeformed beam.


%%
% The twisted beam is discretized with solid elements. Different kinds of
% elements are employed  in order to illustrate the relative accuracy.

%%
%
% <html>
% <table border=0><tr><td>
% <img src="../docs/pub_Twisted_beam.png" width="35%">
% </td></tr>
% <tr><td>Figure 1. Definition of the geometry of the thick elliptical plate</td></tr>
% </table>
% </html>



%%
%
% References:
%%
% # Macneal RH, Harder RL (1985) A proposed standard set of problems to test finite element accuracy. Finite Elements in Analysis and Design 1: 3-20.
% # Zupan D, Saje M (2004) On "A proposed standard set of problems to test
% finite element accuracy": the twisted beam. Finite Elements in Analysis
% and Design 40: 1445-1451.
%% Solution
%
function  pub_Twisted_beam

%%
% The material parameters and dimensions are in consistent units.
E=0.29e8;% Young's modulus
nu=0.22;% Poisson's ratio
W=1.1;%  width of the cross-section
L=12;% length of the beam
t= 0.32;% thickness of the cross-section
tolerance  =0.001*t;% geometrical tolerance
%%
% The beam is loaded with unit force at the free cross-section.  Therefore
% the traction component is  1.0 divided by the cross-sectional area.
p=  1/W/t;%
%%
% For the load in the the  Z direction Macneal and Harder list the
% deflection in the direction of the load of 5.424e-3 units.  The
% deflection used here was determined by running a series of simulations
% and extrapolating to the limit.
load{3}.traction=[0;0;p];
load{3}.utipex=0.005424534868469;
%%
% For the load in the the  Y direction  Macneal and Harder list the
% deflection in the direction of the load of 1.754e-3 units.  The
% deflection used here was determined by running a series of simulations
% and extrapolating to the limit.
load{2}.traction=[0;p;0];
load{2}.utipex=0.001753248285256;



%%
% The usual 3-D material property  and triaxial material  object:
prop=property_deformation_linear_iso(struct('E',E,'nu',nu));
mater = material_deformation_linear_triax (struct('property',prop ));


%%
% The coarsest mesh will have two elements lengthwise and one element
% across the width and across the thickness.
nl=2; nt=1; nw=1;% number of elements employed


%%
% For each combination of element type and load direction and  mesh
% refinement  we will execute the simulation using this function.
    function [utip,nfreedofs] = simulate(...
            mf, ...% mesh function handle
            femmf, ...% finite element model machine function handle
            surface_integration_rule,...% rule to integrate the traction loads
            load_dir,...% load direction (2 or 3)
            ref...% refinement factor (>=1)
            )
        % Create the mesh and initialize the geometry.
        [fens,fes]= mf(L,W,t, nl*ref,nw*ref,nt*ref);
        % Now shape  the twisted beam by rotating each cross-section by an
        % appropriate angle about the axis of the beam.
        xyz=fens.xyz;
        for i=1:count (fens)
            a=xyz(i,1)/L*(pi/2); y=xyz(i,2)-(W/2); z=xyz(i,3)-(t/2);
            xyz(i,:)=[xyz(i,1),y*cos(a)-z*sin(a),y*sin(a)+z*cos(a)];
        end
        fens.xyz=xyz;
        % Compose the model data
        clear model_data
        model_data.fens =fens;
        clear region
        region.fes= fes;
        region.femm= femmf(fes);
        model_data.region{1} =region;
        %         The clamped end: all displacements  fixed.
        clear essential
        essential.component= [1,2,3];
        essential.fixed_value= 0;
        essential.node_list = fenode_select (fens,...
            struct ('box',[0 0 -inf inf -inf inf],'inflate',tolerance));
        model_data.boundary_conditions.essential{1} = essential;
        % The free end cross-section is loaded with the force.
        clear traction
        bdry_fes = mesh_boundary(fes, []);
        bcl = fe_select(fens, bdry_fes, ...
            struct ('box',[L L -inf inf -inf inf],'inflate',tolerance));
        traction.fes =subset(bdry_fes,bcl);;
        traction.traction= load{load_dir}.traction;
        traction.integration_rule =surface_integration_rule;
        model_data.boundary_conditions.traction{1} = traction;
        % Solve
        model_data =deformation_linear_statics(model_data);
        % Collect  the displacements of all the nodes at the free end
        enl=connected_nodes(model_data.boundary_conditions.traction{1}.fes);
        uv=gather_values (model_data.u,enl);
        % and the "tip" displacement will be the mean of those
        % displacements
        utip= mean(uv(:,load_dir));
        nfreedofs  =model_data.u.nfreedofs;
    end


%%
% The response to the loads in different directions varies, but in the
% interest of brevity we will  consider only the direction of axis Y.
load_dir=2;
%%
% The first element we consider is the quadratic tetrahedron.
description ='T10';% tetrahedron
mf =@T10_block;
femmf =@(fes)femm_deformation_linear(struct('fes',fes,'material',mater,...
    'integration_rule',tet_rule(struct('npts',4))));
surface_integration_rule=tri_rule(struct('npts',3));
ref=1;
[utip,nfreedofs] = ...
    simulate(mf,femmf,surface_integration_rule,load_dir,ref);
disp (['%Normalized displacement =' num2str(utip/load{load_dir}.utipex)])

%%
% The displacement  is just 50% of the target value, but the mesh is
% admittedly very  coarse (just two elements along the length).
ref=2;
[utip,nfreedofs] = ...
    simulate(mf,femmf,surface_integration_rule,load_dir,ref);
disp (['%Normalized displacement =' num2str(utip/load{load_dir}.utipex)])

%%
% In order to appreciate  the convergence of this model we will execute the
% simulation in a loop and plot the results.
for ref=1:4
    [utip(ref),nfreedofs(ref)] = ...
        simulate(mf,femmf,surface_integration_rule,load_dir,ref);
end

%%
% The normalized true error is plotted on a log log scale:
loglog(nfreedofs,abs(utip-load{load_dir}.utipex)/load{load_dir}.utipex,...
    'k^REPLACE_WITH_DASH_DASH');
add_to_legend(description);
labels( 'Number of degrees of freedom', ...
    'Normalized true error of the deflection');
%%
% How will a different element  compare with the quadratic tetrahedron?
% Here is the  20-node serendipity hexahedron:
description ='H20R';
mf =@H20_block;
femmf =@(fes)femm_deformation_linear(struct('fes',fes, 'material',mater,...
    'integration_rule',gauss_rule(struct('dim',3, 'order',2))));
surface_integration_rule=gauss_rule(struct('dim',2, 'order',2));
for ref=1:4
    [utip(ref),nfreedofs(ref)] = ...
        simulate(mf,femmf,surface_integration_rule,load_dir,ref);
end
hold on
loglog(nfreedofs,abs(utip-load{load_dir}.utipex)/load{load_dir}.utipex,...
    'roREPLACE_WITH_DASH_DASH');
add_to_legend(description);

%%
% For comparison we show the performance of the basic isoparametric eight
% node hexahedron.
description ='H8';
mf =@H8_block;
femmf =@(fes)femm_deformation_linear(struct('fes',fes, 'material',mater,...
    'integration_rule',gauss_rule(struct('dim',3, 'order',2))));
surface_integration_rule=gauss_rule(struct('dim',2, 'order',2));
for ref=1:6
    [utip(ref),nfreedofs(ref)] = ...
        simulate(mf,femmf,surface_integration_rule,load_dir,ref);
end
hold on
loglog(nfreedofs,abs(utip-load{load_dir}.utipex)/load{load_dir}.utipex,...
    'mdREPLACE_WITH_DASH_DASH');
add_to_legend(description);

%%
% It is rather a sorry sight, the bending accuracy of the H8 hexahedron is
% dismal. It may be improved markedly using yet again the device of
% selective reduced integration.  This time the shear response is going to
% be under-integrated.
description ='H8-SRI';
mf =@H8_block;
femmf =@(fes)femm_deformation_linear_sri(struct('fes',fes, 'material',mater,...
    'integration_rule_volumetric',gauss_rule(struct('dim',3, 'order',2)),...
    'integration_rule_deviatoric',gauss_rule(struct('dim',3, 'order',1))));
surface_integration_rule=gauss_rule(struct('dim',2, 'order',2));
for ref=1:6
    [utip(ref),nfreedofs(ref)] = ...
        simulate(mf,femmf,surface_integration_rule,load_dir,ref);
end
hold on
loglog(nfreedofs,abs(utip-load{load_dir}.utipex)/load{load_dir}.utipex,...
    'md-');
add_to_legend(description);

end

##### SOURCE END #####
--></body></html>