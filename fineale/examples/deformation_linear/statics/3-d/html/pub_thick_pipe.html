
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Thick pipe with internal pressure</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-12-19"><meta name="DC.source" content="pub_thick_pipe.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Thick pipe with internal pressure</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Description</a></li><li><a href="#6">Solution</a></li><li><a href="#51">Discussion</a></li></ul></div><p>Link to the  <a href="matlab:edit('pub_thick_pipe')">m-file</a>.</p><h2>Description<a name="2"></a></h2><p>An infinitely long thick walled cylindrical pipe with inner boundary radius of 3 mm and outer boundary radius of 9 mm is subjected to an internal pressure of 1.0 MPa. A wedge   with thickness of  2 mm and a 90-degree angle sector is considered for the finite element analysis. The material properties are taken as  isotropic linear elastic with <img src="pub_thick_pipe_eq17257192073853546320.png" alt="$E=1000$"> MPa and <img src="pub_thick_pipe_eq03077024200717292670.png" alt="$\nu=0.4999$"> to represent nearly incompressible behavior. This problem has been proposed to by MacNeal and Harder as a test of an element's ability to represent the  response of a nearly incompressible material. The plane-strain condition is assumed in the axial direction of the pipe which together with the radial symmetry confines the material in all but the radial direction and therefore amplifies the numerical difficulties associated with the confinement of the nearly incompressible material.</p><p>There is an analytical solution to this problem. Timoshenko and Goodier presented the original solution of Lame in their textbook. We are going to compare with  both the stress distribution (radial and hoop stresses) and the displacement of the inner  cylindrical surface.</p><p>
<table border=0><tr><td>
<img src="../docs/pub_thick_pipe.png" width = "30%">
</td></tr>
<tr><td>Figure 1. Definition of the geometry of the internally pressurized thick pipe</td></tr>
</table>
</p><p>References:</p><div><ol><li>Macneal RH, Harder RL (1985) A proposed standard set of problems to test finite element accuracy. Finite Elements in Analysis and Design 1: 3-20.</li></ol></div><div><ol><li>Timoshenko S. and Goodier J. N., Theory of Elasticity, McGraw-Hill, 2nd ed., 1951.</li></ol></div><h2>Solution<a name="6"></a></h2><pre class="codeinput"><span class="keyword">function</span> pub_thick_pipe
</pre><pre class="codeinput">    u= physical_units_struct;
</pre><p>Internal radius of the pipe.</p><pre class="codeinput">    a=3*u.MM;
</pre><p>External radius of the pipe.</p><pre class="codeinput">    b=9*u.MM;
</pre><p>Length of the section of the pipe (thickness of the slice).</p><pre class="codeinput">    t=2*u.MM;
</pre><p>Geometrical tolerance.</p><pre class="codeinput">    tolerance  =a/10000;
</pre><p>Young's modulus and Poisson's ratio.</p><pre class="codeinput">    E=1000*u.MEGA*u.PA;
    nu=0.499;
</pre><p>Applied pressure on the internal surface.</p><pre class="codeinput">    p=  1*u.MEGA*u.PA;
</pre><p>Analytical solutions.   Radial stress:</p><pre class="codeinput">    radial_stress =@(r)p*a.^2/(b^2-a^2).*(1-b^2./r.^2);
</pre><p>Circumferential (hoop) stress:</p><pre class="codeinput">    hoop_stress =@(r)p*a.^2/(b^2-a^2).*(1+b^2./r.^2);
</pre><p>Radial displacement:</p><pre class="codeinput">    radial_displacement=@(r)p*a^2*(1+nu)*(b^2+r.^2*(1-2*nu))/(E*(b^2-a^2).*r);;
</pre><p>Therefore the radial displacement of the loaded surface will be:</p><pre class="codeinput">    urex = radial_displacement(a);
</pre><p>The mesh parameters: The numbers of element edges circumferentially, through the thickness of the slice (axially for the pipe), and through the thickness of the pipe wall (radially).</p><pre class="codeinput">    nc=4; ny=1;  nt=5;
</pre><p>The material is homogeneous, isotropic, fully three-dimensional.</p><pre class="codeinput">    prop=property_deformation_linear_iso(struct(<span class="string">'E'</span>,E,<span class="string">'nu'</span>,nu));
    mater = material_deformation_linear_triax (struct(<span class="string">'property'</span>,prop ));
</pre><p>This function will execute the simulation for a particular finite element with selected numerical integration rules. The arguments are:</p><pre>description = descriptive string
mf  = handle to a block-meshing function
femmf = handle to a function constructing the finite element model machine,
surface_integration_rule = surface integration rule</pre><pre class="codeinput">    <span class="keyword">function</span>  execute_simulation (description, mf, femmf, <span class="keyword">...</span>
            surface_integration_rule)
        <span class="comment">% Create the mesh and initialize the geometry.  First we are going</span>
        <span class="comment">% to construct the block of elements with the first coordinate</span>
        <span class="comment">% corresponding to the angle,  the second coordinate is the</span>
        <span class="comment">% thickness of the slicing the axial direction, and the third</span>
        <span class="comment">% coordinate is the thickness in the radial direction.</span>
        anglrrange=90/180*pi;
        [fens,fes]=  mf (anglrrange, t, b-a, nc, ny, nt);
        <span class="comment">% Extract the boundary  and mark the finite elements on the</span>
        <span class="comment">% interior surface.</span>
        bdry_fes = mesh_boundary(fes, struct(<span class="string">'other_dimension'</span>,1.0));
        bcl = fe_select(fens, bdry_fes, <span class="keyword">...</span>
            struct (<span class="string">'box'</span>,[-inf,inf,-inf,inf,0,0],<span class="string">'inflate'</span>,tolerance));
        internal_fenids= connected_nodes (subset(bdry_fes,bcl));
        <span class="comment">% Now  shape the block  into  the actual wedge piece of the pipe.</span>
        ayr=fens.xyz;
        <span class="keyword">for</span> i=1:count (fens)
            angl=ayr(i,1); y=ayr(i,2); r=a+ayr(i,3);
            fens.xyz(i,:)=[r*sin(angl) y (r*cos(angl))];
        <span class="keyword">end</span>
        <span class="comment">% Compose the model data</span>
        clear <span class="string">model_data</span>
        model_data.fens =fens;
        <span class="comment">% The region is cconstructed directly with the finite element</span>
        <span class="comment">% model machine produced according to the instructions coded for</span>
        <span class="comment">% each element differently. This gives us an opportunity to  exert</span>
        <span class="comment">% find control over which integration rule is to be used.   In</span>
        <span class="comment">% particular, the selective reduced integration rule may be</span>
        <span class="comment">% introduced.</span>
        clear <span class="string">region</span>
        region.femm= femmf(fes);
        model_data.region{1} =region;
        <span class="comment">% The symmetry boundary condition  is specified by selecting nodes</span>
        <span class="comment">% on the plane x=0.</span>
        clear <span class="string">essential</span>
        essential.component= [1];
        essential.fixed_value= 0;
        essential.node_list = fenode_select (fens,<span class="keyword">...</span>
            struct (<span class="string">'box'</span>,[0 0 -inf,inf -inf,inf],<span class="string">'inflate'</span>,tolerance));
        model_data.boundary_conditions.essential{1} = essential;
        <span class="comment">% The constraint in the axial direction is  specified</span>
        <span class="comment">% next.  The nodes on the planes y=0 and y=t are selected.</span>
        clear <span class="string">essential</span>
        essential.component= [2];
        essential.fixed_value= 0;
        essential.node_list = [fenode_select(fens,<span class="keyword">...</span>
            struct (<span class="string">'box'</span>,[-inf,inf 0 0 -inf,inf],<span class="string">'inflate'</span>,tolerance)),<span class="keyword">...</span>
            fenode_select(fens,<span class="keyword">...</span>
            struct (<span class="string">'box'</span>,[-inf,inf t t -inf,inf],<span class="string">'inflate'</span>,tolerance))];
        model_data.boundary_conditions.essential{2} = essential;
        <span class="comment">% The second symmetry boundary condition is specified by selecting</span>
        <span class="comment">% nodes on the plane z=0.</span>
        clear <span class="string">essential</span>
        essential.component= [3];
        essential.fixed_value= 0;
        essential.node_list = fenode_select (fens,<span class="keyword">...</span>
            struct (<span class="string">'box'</span>,[-inf,inf -inf,inf 0 0],<span class="string">'inflate'</span>,tolerance));
        model_data.boundary_conditions.essential{3} = essential;
        <span class="comment">% The traction boundary condition is applied in the radial</span>
        <span class="comment">% direction.</span>
        clear <span class="string">traction</span>
        traction.fes =subset(bdry_fes,bcl);;
        traction.traction= @(x) (p*([1,0,1].*x)'/norm(([1,0,1].*x)));
        traction.integration_rule =surface_integration_rule;
        model_data.boundary_conditions.traction{1} = traction;

        <span class="comment">% Call the statics solver to obtain the displacement solution.</span>
        model_data =deformation_linear_statics(model_data);


        <span class="comment">% Transfer the solution of the displacement to the nodes on the</span>
        <span class="comment">% internal cylindrical surface and convert to</span>
        <span class="comment">% cylindrical-coordinate displacements there.</span>
        uv=gather_values (model_data.u,internal_fenids);
        ur=0*internal_fenids;
        xyz=fens.xyz;
        <span class="keyword">for</span> j=1:length(internal_fenids)
            n=[xyz(internal_fenids(j),1),0,xyz(internal_fenids(j),3)];
            n=n'/norm(n);<span class="comment">% normal to the cylindrical internal surface</span>
            ur(j)=uv(j,:)*n;
        <span class="keyword">end</span>
        <span class="comment">% Report the  relative displacement on the internal surface:</span>
        disp([<span class="string">'(Approximate/true displacement) at the internal surface: '</span><span class="keyword">...</span>
            num2str(mean(ur)/urex*100) <span class="string">'%'</span>])

        <span class="comment">% Produce a plot of the Cartesian stress component. Note that this</span>
        <span class="comment">% is the usual representation of stress using nodal stress field.</span>
        model_data.postprocessing.u_scale= 200;
        model_data.postprocessing.stress_component=3;
        model_data.postprocessing.stress_range=[-p,+p];
        model_data=deformation_plot_stress(model_data);
        draw_annotation(model_data.postprocessing.gv,<span class="keyword">...</span>
            [0.35, 0.8, 0.35, 0.075],description,<span class="keyword">...</span>
            struct(<span class="string">'backgroundcolor'</span>,<span class="string">'w'</span>))

        <span class="comment">% Produce a plot of the solution components in the cylindrical</span>
        <span class="comment">% coordinate system.</span>
        <span class="comment">% Plot the analytical solution.</span>
        figure;
        r  =linspace(a,b,100);
        plot(r,radial_stress(r),<span class="string">'k.-'</span>,<span class="string">'linewidth'</span>,3); hold <span class="string">on</span>
        context. output=<span class="string">'Cauchy'</span>;
        idat.component =1; <span class="comment">%  Radial component of stress</span>
        <span class="comment">% For all finite elements in the finite element model machine:</span>
        <span class="keyword">for</span> ii=1:count(model_data.region{1}.femm.fes)
            <span class="comment">% Now go through the  integration points in the finite element</span>
            <span class="comment">% number ii, compute the stress components in the global</span>
            <span class="comment">% Cartesian coordinate system, then transform the stress</span>
            <span class="comment">% components into the cylindrical coordinate system.</span>
            idat.r =[]; idat.s =[];
            idat = inspect_integration_points(model_data.region{1}.femm, <span class="keyword">...</span>
                model_data.geom, model_data.u, [], ii, context,<span class="keyword">...</span>
                @inspector, idat);
            <span class="comment">% Plot the stress at each integration point in the graph.</span>
            <span class="keyword">for</span> j  =1:length(idat.r)
                plot(idat.r(j),idat.s(j),<span class="string">'rx'</span>,<span class="string">'linewidth'</span>,3); hold <span class="string">on</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        title([description])
        labels(<span class="string">'Radial distance'</span>, <span class="string">'Stress $\sigma_r$'</span>)
        set_graphics_defaults

    <span class="keyword">end</span>
</pre><p>This is a helper function for the calculation of the integration-point stresses.</p><pre class="codeinput">    <span class="keyword">function</span> idat =inspector(idat, out, xyz, u_xyz, pc)
        theNormal=[xyz(1),0,xyz(3)];
        r=norm(theNormal);<span class="comment">% distance from the axis of symmetry</span>
        theNormal =theNormal/r;<span class="comment">% compute the unit normal vector</span>
        e1p=theNormal';<span class="comment">% local cylindrical coordinate system basis vectors</span>
        e3p=[0,1,0]';<span class="comment">% this one points along the axis of the cylinder</span>
        e2p=skewmat(e3p)*e1p;<span class="comment">% this one is along the hoop direction</span>
        Rm= [e1p,e2p,e3p];<span class="comment">% transformation matrix for the stress</span>
        tm = stress_6v_to_3x3t (mater,out);<span class="comment">% stress in global XYZ</span>
        tpm = Rm'*tm*Rm;<span class="comment">%  stress matrix in cylindrical coordinates</span>
        sp = stress_3x3t_to_6v(mater,tpm);<span class="comment">% stress vector in cylindr. coord.</span>
        idat.r(end+1) =r;
        idat.s(end+1)=sp(idat.component);
    <span class="keyword">end</span>
</pre><p><b>Regular quadratic tetrahedron</b></p><p>We start with the workhorse of most commonly used finite element packages, the quadratic tetrahedron. The finite element model machine is just the default used by the static solver, and the four-point quadrature rule  is also standard for this element.</p><pre class="codeinput">    description =<span class="string">'T10'</span>;<span class="comment">% tetrahedron</span>
    mf =@T10_block;
    femmf =@(fes)femm_deformation_linear(struct(<span class="string">'fes'</span>,fes,<span class="keyword">...</span>
        <span class="string">'material'</span>,mater,<span class="string">'integration_rule'</span>,tet_rule(struct(<span class="string">'npts'</span>,4))));
    surface_integration_rule=tri_rule(struct(<span class="string">'npts'</span>,3));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 99.3758%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_01.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_02.png" alt=""> <p>Nothing seems terribly wrong at first sight.  The  nodal stress plot shows a little bit of discoloration in patches, but the displacement  is only less than a percent off.</p><p>However, when we look at the radial stress plot we can see that there's trouble. The stress at the integration points is way off from the analytical solution.</p><p>Why is the nodal stress field okay then?  This may be attributed to the averaging, or smoothing, of the integration point values when they are getting converted into the node-based stress field.  That process will take care of all that jumping around and settled to the "average" which may not be  far away from the true stress.</p><p><b>Reduced integration serendipity hexahedron</b></p><p>An element that is often used in these situations is the uniformly under integrated serendipity (20-node) hexahedron. The same finite element model machine as above is used, and the integration is the Gauss rule one order lower than that required for full integration (which would be  3 x 3 x 3).</p><pre class="codeinput">    description =<span class="string">'H20R'</span>;
    mf =@H20_block;
    femmf =@(fes)femm_deformation_linear(struct(<span class="string">'fes'</span>,fes,<span class="keyword">...</span>
        <span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'integration_rule'</span>,gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,2))));
    surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,2));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 100.0168%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_03.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_04.png" alt=""> <p>We can see that all the output points towards great performance from this element.  The stress is smooth, in fact right on top of the analytical prediction.</p><p><b>Full integration serendipity hexahedron</b></p><p>It isn't difficult to spoil this picture.  Here we use the same element, except for replacing the quadrature with full  3 x 3 x 3 Gauss rule (indicated by %&lt;==).</p><pre class="codeinput"> description =<span class="string">'H20'</span>;
    mf =@H20_block;
    femmf =@(fes)femm_deformation_linear(struct(<span class="string">'fes'</span>,fes,<span class="keyword">...</span>
        <span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'integration_rule'</span>,gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,3))));<span class="comment">%&lt;==</span>
    surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,2));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 95.2348%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_05.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_06.png" alt=""> <p>The stress is now totally unacceptable.</p><p><b>Lagrange 27-node quadratic hexahedron</b></p><p>Using a Lagrange 27-node quadratic hexahedron instead of the serendipity 20-node hexahedron  does not help.</p><pre class="codeinput">    description =<span class="string">'H27'</span>;
    mf =@H27_block;
    femmf =@(fes)femm_deformation_linear(struct(<span class="string">'fes'</span>,fes,<span class="keyword">...</span>
        <span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'integration_rule'</span>,gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,3))));
    surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,4));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 95.2399%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_07.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_08.png" alt=""> <p>In fact, the results are as bad if not worse. Unfortunately, the remedy of using reduced  (under) integration that worked for the 20 node hexahedron is now   not available anymore.</p><p><b>Regular cubic hexahedron</b></p><p>Would it help to go to a cubic Lagrange hexahedron?</p><pre class="codeinput">    description =<span class="string">'H64'</span>;
    mf =@H64_block;
    femmf =@(fes)femm_deformation_linear(struct(<span class="string">'fes'</span>,fes, <span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'integration_rule'</span>,gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,4))));
    surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,4));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 99.9405%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_09.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_10.png" alt=""> <p>Unfortunately, the answer is no.  The stress still oscillates.</p><p>The remedy both for the 27- and 64-node hexahedron is <i>selective</i> reduced integration. In contrast to the uniform reduced integration (which is not available for these elements as they would be producing singular stiffness matrices), the selective reduced integration applies different integration rules to compute terms associated with dilatation (volumetric) strains and those associated with shear (deviatoric) strains.</p><p><b>Selective reduced integration cubic hexahedron</b></p><p>The finite element model machine is now replaced with a specialized version  that can use different integration rules for different terms. The volumetric rule is the reduced integration rule, in the case of the cubic hexahedron 3 x 3 x 3.  The shear-strain rule is the full Gauss rule appropriate for this element.</p><pre class="codeinput">    description =<span class="string">'H64-SRI'</span>;
    mf =@H64_block;
    femmf =@(fes)femm_deformation_linear_sri(struct(<span class="string">'fes'</span>,fes, <span class="keyword">...</span>
        <span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'integration_rule_volumetric'</span>,<span class="keyword">...</span>
        gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,3)),<span class="keyword">...</span>
        <span class="string">'integration_rule_deviatoric'</span>,<span class="keyword">...</span>
        gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,4))));
    surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,4));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 99.9999%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_11.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_12.png" alt=""> <p>Clearly, the selective reduced integration removed all the oscillations and the  approximation of the stress is right on the money.</p><p>The same remedy also works for the 27-node hexahedron.  We just have to reduce the Gauss rule orders by one.</p><pre class="codeinput">        description =<span class="string">'H27-SRI'</span>;
    mf =@H27_block;
    femmf =@(fes)femm_deformation_linear_sri(struct(<span class="string">'fes'</span>,fes, <span class="keyword">...</span>
        <span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'integration_rule_volumetric'</span>,<span class="keyword">...</span>
        gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,2)),<span class="keyword">...</span>
        <span class="string">'integration_rule_deviatoric'</span>,<span class="keyword">...</span>
        gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,3))));
    surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,4));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 99.9781%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_13.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_14.png" alt=""> <p>Again, oscillations gone, stress is very accurate overall.</p><p>As a matter of fact, even the least accurate hexahedron available, the H8 hexahedron with 8  nodes which does not give an acceptable accuracy as a rule, is in this case just fine when the selective reduced integration is applied.</p><p><b>Selective reduced integration H8 hexahedron</b></p><pre class="codeinput">    description =<span class="string">'H8-SRI'</span>;
    mf =@H8_block;
    femmf =@(fes)femm_deformation_linear_sri(struct(<span class="string">'fes'</span>,fes, <span class="keyword">...</span>
        <span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'integration_rule_volumetric'</span>,<span class="keyword">...</span>
        gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,1)),<span class="keyword">...</span>
        <span class="string">'integration_rule_deviatoric'</span>,<span class="keyword">...</span>
        gauss_rule(struct(<span class="string">'dim'</span>,3, <span class="string">'order'</span>,2))));
    surface_integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,2, <span class="string">'order'</span>,2));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 97.9954%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_15.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_16.png" alt=""> <p>Finally we come back to the T10 tetrahedron. The same remedy, selective reduced integration, also works for the quadratic tetrahedron.  The deviatoric rule is  the original 4-point one, and the volumetric rule is just a single-point quadrature.</p><p><b>Selective reduced integration quadratic tetrahedron</b></p><pre class="codeinput">    description =<span class="string">'T10-SRI'</span>;
    mf =@T10_block;
    femmf =@(fes)femm_deformation_linear_sri(struct(<span class="string">'fes'</span>,fes,<span class="keyword">...</span>
        <span class="string">'material'</span>,mater,<span class="keyword">...</span>
        <span class="string">'integration_rule_volumetric'</span>,tet_rule(struct(<span class="string">'npts'</span>,1)),<span class="keyword">...</span>
        <span class="string">'integration_rule_deviatoric'</span>,tet_rule(struct(<span class="string">'npts'</span>,4))));
    surface_integration_rule=tri_rule(struct(<span class="string">'npts'</span>,3));
    execute_simulation (description, mf, femmf, surface_integration_rule);
</pre><pre class="codeoutput">(Approximate/true displacement) at the internal surface: 100.0129%
</pre><img vspace="5" hspace="5" src="pub_thick_pipe_17.png" alt=""> <img vspace="5" hspace="5" src="pub_thick_pipe_18.png" alt=""> <p>The stresses show a little bit of a loss of accuracy, which presumably is due to the fact that the tetrahedral mesh has some unsymmetry associated with it whereas the hexahedral mesh is perfectly aligned with the boundaries of the modeled wedge/slice.</p><h2>Discussion<a name="51"></a></h2><p>If we were simulating the response of  compressible material, for instance for <img src="pub_thick_pipe_eq00495845292348252579.png" alt="$\nu=0.3$"> (steel) the finite elements tested above  would <i>all</i> work fine. For Poisson's ratio approaching 1/2 ordinary isoparametric displacement-based finite elements may fail.</p><p>For nearly incompressible materials with displacement-based finite elements (all of those above) we are always better off using a trick such as the selective reduced integration  (or uniform reduced integration for the H20 hexahedron) than the full integration.    Sometimes we have the option of switching to methods specially designed to deal with incompressibility, such as the mixed approximation of pressure plus displacement. If that is not available, displacement-only  finite element with  a selective reduced integration is a good bet.</p><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Thick pipe with internal pressure
%

%%
% Link to the  <matlab:edit('pub_thick_pipe') m-file>.

%% Description
% An infinitely long thick walled cylindrical pipe with inner boundary
% radius of 3 mm and outer boundary radius of 9 mm is subjected to an
% internal pressure of 1.0 MPa. A wedge   with thickness of  2 mm and a
% 90-degree angle sector is considered for the finite element analysis. The
% material properties are taken as  isotropic linear elastic with $E=1000$
% MPa and $\nu=0.4999$ to represent nearly incompressible behavior. This
% problem has been proposed to by MacNeal and Harder as a test of an
% element's ability to represent the  response of a nearly incompressible
% material. The plane-strain condition is assumed in the axial direction of
% the pipe which together with the radial symmetry confines the material in
% all but the radial direction and therefore amplifies the numerical
% difficulties associated with the confinement of the nearly incompressible
% material.
%%
% There is an analytical solution to this problem. Timoshenko and Goodier
% presented the original solution of Lame in their textbook. We are going
% to compare with  both the stress distribution (radial and hoop stresses)
% and the displacement of the inner  cylindrical surface.

%%
%
% <html>
% <table border=0><tr><td>
% <img src="../docs/pub_thick_pipe.png" width = "30%">
% </td></tr>
% <tr><td>Figure 1. Definition of the geometry of the internally pressurized thick pipe</td></tr>
% </table>
% </html>

%%
% References:
%
% # Macneal RH, Harder RL (1985) A proposed standard set of problems to test
% finite element accuracy. Finite Elements in Analysis and Design 1: 3-20.
%
% # Timoshenko S. and Goodier J. N., Theory of Elasticity, McGraw-Hill, 2nd ed., 1951.

%% Solution
%
function pub_thick_pipe
    u= physical_units_struct;
    %%
    % Internal radius of the pipe.
    a=3*u.MM;
    %%
    % External radius of the pipe.
    b=9*u.MM;
    
    %%
    % Length of the section of the pipe (thickness of the slice).
    t=2*u.MM;
    %%
    % Geometrical tolerance.
    tolerance  =a/10000;
    %%
    % Young's modulus and Poisson's ratio.
    E=1000*u.MEGA*u.PA;
    nu=0.499;
    %%
    % Applied pressure on the internal surface.
    p=  1*u.MEGA*u.PA;
    
    %%
    % Analytical solutions.   Radial stress:
    radial_stress =@(r)p*a.^2/(b^2-a^2).*(1-b^2./r.^2);
    %%
    % Circumferential (hoop) stress:
    hoop_stress =@(r)p*a.^2/(b^2-a^2).*(1+b^2./r.^2);
    
    %%
    % Radial displacement:
    radial_displacement=@(r)p*a^2*(1+nu)*(b^2+r.^2*(1-2*nu))/(E*(b^2-a^2).*r);;
    
    %%
    % Therefore the radial displacement of the loaded surface will be:
    urex = radial_displacement(a);
    
    
    %%
    % The mesh parameters: The numbers of element edges circumferentially,
    % through the thickness of the slice (axially for the pipe), and through
    % the thickness of the pipe wall (radially).
    
    nc=4; ny=1;  nt=5;
    
%% 
% The material is homogeneous, isotropic, fully three-dimensional.    
    prop=property_deformation_linear_iso(struct('E',E,'nu',nu));
    mater = material_deformation_linear_triax (struct('property',prop ));
    
    
    %%
    % This function will execute the simulation for a particular finite element
    % with selected numerical integration rules. The arguments are:
    %%
    %
    %  description = descriptive string
    %  mf  = handle to a block-meshing function
    %  femmf = handle to a function constructing the finite element model machine,
    %  surface_integration_rule = surface integration rule
    function  execute_simulation (description, mf, femmf, ...
            surface_integration_rule)
        % Create the mesh and initialize the geometry.  First we are going
        % to construct the block of elements with the first coordinate
        % corresponding to the angle,  the second coordinate is the
        % thickness of the slicing the axial direction, and the third
        % coordinate is the thickness in the radial direction.
        anglrrange=90/180*pi;
        [fens,fes]=  mf (anglrrange, t, b-a, nc, ny, nt);
        % Extract the boundary  and mark the finite elements on the
        % interior surface.
        bdry_fes = mesh_boundary(fes, struct('other_dimension',1.0));
        bcl = fe_select(fens, bdry_fes, ...
            struct ('box',[-inf,inf,-inf,inf,0,0],'inflate',tolerance));
        internal_fenids= connected_nodes (subset(bdry_fes,bcl));
        % Now  shape the block  into  the actual wedge piece of the pipe.
        ayr=fens.xyz;
        for i=1:count (fens)
            angl=ayr(i,1); y=ayr(i,2); r=a+ayr(i,3);
            fens.xyz(i,:)=[r*sin(angl) y (r*cos(angl))];
        end
        % Compose the model data
        clear model_data
        model_data.fens =fens;
        % The region is cconstructed directly with the finite element
        % model machine produced according to the instructions coded for
        % each element differently. This gives us an opportunity to  exert
        % find control over which integration rule is to be used.   In
        % particular, the selective reduced integration rule may be
        % introduced.
        clear region
        region.femm= femmf(fes);
        model_data.region{1} =region;
        % The symmetry boundary condition  is specified by selecting nodes
        % on the plane x=0.
        clear essential
        essential.component= [1];
        essential.fixed_value= 0;
        essential.node_list = fenode_select (fens,...
            struct ('box',[0 0 -inf,inf -inf,inf],'inflate',tolerance));
        model_data.boundary_conditions.essential{1} = essential;
        % The constraint in the axial direction is  specified
        % next.  The nodes on the planes y=0 and y=t are selected.
        clear essential
        essential.component= [2];
        essential.fixed_value= 0;
        essential.node_list = [fenode_select(fens,...
            struct ('box',[-inf,inf 0 0 -inf,inf],'inflate',tolerance)),...
            fenode_select(fens,...
            struct ('box',[-inf,inf t t -inf,inf],'inflate',tolerance))];
        model_data.boundary_conditions.essential{2} = essential;
        % The second symmetry boundary condition is specified by selecting
        % nodes on the plane z=0.
        clear essential
        essential.component= [3];
        essential.fixed_value= 0;
        essential.node_list = fenode_select (fens,...
            struct ('box',[-inf,inf -inf,inf 0 0],'inflate',tolerance));
        model_data.boundary_conditions.essential{3} = essential;
        % The traction boundary condition is applied in the radial
        % direction.
        clear traction
        traction.fes =subset(bdry_fes,bcl);;
        traction.traction= @(x) (p*([1,0,1].*x)'/norm(([1,0,1].*x)));
        traction.integration_rule =surface_integration_rule;
        model_data.boundary_conditions.traction{1} = traction;
        
        % Call the statics solver to obtain the displacement solution.
        model_data =deformation_linear_statics(model_data);
        
        
        % Transfer the solution of the displacement to the nodes on the
        % internal cylindrical surface and convert to
        % cylindrical-coordinate displacements there.
        uv=gather_values (model_data.u,internal_fenids);
        ur=0*internal_fenids;
        xyz=fens.xyz;
        for j=1:length(internal_fenids)
            n=[xyz(internal_fenids(j),1),0,xyz(internal_fenids(j),3)];
            n=n'/norm(n);% normal to the cylindrical internal surface
            ur(j)=uv(j,:)*n;
        end
        % Report the  relative displacement on the internal surface:
        disp(['(Approximate/true displacement) at the internal surface: '...
            num2str(mean(ur)/urex*100) '%'])
        
        % Produce a plot of the Cartesian stress component. Note that this
        % is the usual representation of stress using nodal stress field.
        model_data.postprocessing.u_scale= 200;
        model_data.postprocessing.stress_component=3;
        model_data.postprocessing.stress_range=[-p,+p];
        model_data=deformation_plot_stress(model_data);
        draw_annotation(model_data.postprocessing.gv,...
            [0.35, 0.8, 0.35, 0.075],description,...
            struct('backgroundcolor','w'))
        
        % Produce a plot of the solution components in the cylindrical
        % coordinate system.
        % Plot the analytical solution.
        figure;
        r  =linspace(a,b,100);
        plot(r,radial_stress(r),'k.-','linewidth',3); hold on
        context. output='Cauchy';
        idat.component =1; %  Radial component of stress
        % For all finite elements in the finite element model machine:
        for ii=1:count(model_data.region{1}.femm.fes)
            % Now go through the  integration points in the finite element
            % number ii, compute the stress components in the global
            % Cartesian coordinate system, then transform the stress
            % components into the cylindrical coordinate system.
            idat.r =[]; idat.s =[];
            idat = inspect_integration_points(model_data.region{1}.femm, ...
                model_data.geom, model_data.u, [], ii, context,...
                @inspector, idat);
            % Plot the stress at each integration point in the graph.
            for j  =1:length(idat.r)
                plot(idat.r(j),idat.s(j),'rx','linewidth',3); hold on
            end
        end
        title([description])
        labels('Radial distance', 'Stress $\sigma_r$')
        set_graphics_defaults
        
    end
    
%% 
% This is a helper function for the calculation of the integration-point
% stresses.
    function idat =inspector(idat, out, xyz, u_xyz, pc)
        theNormal=[xyz(1),0,xyz(3)];
        r=norm(theNormal);% distance from the axis of symmetry
        theNormal =theNormal/r;% compute the unit normal vector
        e1p=theNormal';% local cylindrical coordinate system basis vectors
        e3p=[0,1,0]';% this one points along the axis of the cylinder
        e2p=skewmat(e3p)*e1p;% this one is along the hoop direction
        Rm= [e1p,e2p,e3p];% transformation matrix for the stress
        tm = stress_6v_to_3x3t (mater,out);% stress in global XYZ
        tpm = Rm'*tm*Rm;%  stress matrix in cylindrical coordinates
        sp = stress_3x3t_to_6v(mater,tpm);% stress vector in cylindr. coord.
        idat.r(end+1) =r;
        idat.s(end+1)=sp(idat.component);
    end
    
    
%% 
% *Regular quadratic tetrahedron*
%% 
% We start with the workhorse of most commonly used finite element
% packages, the quadratic tetrahedron. The finite element model machine is
% just the default used by the static solver, and the four-point quadrature
% rule  is also standard for this element.
    description ='T10';% tetrahedron
    mf =@T10_block;
    femmf =@(fes)femm_deformation_linear(struct('fes',fes,...
        'material',mater,'integration_rule',tet_rule(struct('npts',4))));
    surface_integration_rule=tri_rule(struct('npts',3));
    execute_simulation (description, mf, femmf, surface_integration_rule);
%% 
% Nothing seems terribly wrong at first sight.  The  nodal stress plot
% shows a little bit of discoloration in patches, but the displacement  is
% only less than a percent off.
%% 
% However, when we look at the radial stress plot we can see that there's
% trouble. The stress at the integration points is way off from the
% analytical solution.
%% 
% Why is the nodal stress field okay then?  This may be attributed to the
% averaging, or smoothing, of the integration point values when they are
% getting converted into the node-based stress field.  That process will
% take care of all that jumping around and settled to the "average" which
% may not be  far away from the true stress.
    
    %%
    % *Reduced integration serendipity hexahedron*
%% 
% An element that is often used in these situations is the uniformly under
% integrated serendipity (20-node) hexahedron. The same finite element
% model machine as above is used, and the integration is the Gauss rule one
% order lower than that required for full integration (which would be  3 x
% 3 x 3).
    description ='H20R';
    mf =@H20_block;
    femmf =@(fes)femm_deformation_linear(struct('fes',fes,...
        'material',mater,...
        'integration_rule',gauss_rule(struct('dim',3, 'order',2))));
    surface_integration_rule=gauss_rule(struct('dim',2, 'order',2));
    execute_simulation (description, mf, femmf, surface_integration_rule);
   
%% 
% We can see that all the output points towards great performance from this
% element.  The stress is smooth, in fact right on top of the analytical
% prediction.
 
  
    %%
    % *Full integration serendipity hexahedron*
%% 
% It isn't difficult to spoil this picture.  Here we use the same element,
% except for replacing the quadrature with full  3 x 3 x 3 Gauss rule (indicated by %<==).

 description ='H20';
    mf =@H20_block;
    femmf =@(fes)femm_deformation_linear(struct('fes',fes,...
        'material',mater,...
        'integration_rule',gauss_rule(struct('dim',3, 'order',3))));%<==
    surface_integration_rule=gauss_rule(struct('dim',2, 'order',2));
    execute_simulation (description, mf, femmf, surface_integration_rule);

%% 
% The stress is now totally unacceptable.
    
%% 
% *Lagrange 27-node quadratic hexahedron*
%% 
% Using a Lagrange 27-node quadratic hexahedron instead of the serendipity
% 20-node hexahedron  does not help.
    description ='H27';
    mf =@H27_block;
    femmf =@(fes)femm_deformation_linear(struct('fes',fes,...
        'material',mater,...
        'integration_rule',gauss_rule(struct('dim',3, 'order',3))));
    surface_integration_rule=gauss_rule(struct('dim',2, 'order',4));
    execute_simulation (description, mf, femmf, surface_integration_rule);

%% 
% In fact, the results are as bad if not worse. Unfortunately, the remedy
% of using reduced  (under) integration that worked for the 20 node
% hexahedron is now   not available anymore.
    
%% 
% *Regular cubic hexahedron*
%% 
% Would it help to go to a cubic Lagrange hexahedron?
    description ='H64';
    mf =@H64_block;
    femmf =@(fes)femm_deformation_linear(struct('fes',fes, 'material',mater,...
        'integration_rule',gauss_rule(struct('dim',3, 'order',4))));
    surface_integration_rule=gauss_rule(struct('dim',2, 'order',4));
    execute_simulation (description, mf, femmf, surface_integration_rule);
    
%% 
% Unfortunately, the answer is no.  The stress still oscillates.
%% 
% The remedy both for the 27- and 64-node hexahedron is _selective_ reduced
% integration. In contrast to the uniform reduced integration (which is not
% available for these elements as they would be producing singular
% stiffness matrices), the selective reduced integration applies different
% integration rules to compute terms associated with dilatation
% (volumetric) strains and those associated with shear (deviatoric)
% strains.
%% 
% *Selective reduced integration cubic hexahedron*
%% 
% The finite element model machine is now replaced with a specialized
% version  that can use different integration rules for different terms.
% The volumetric rule is the reduced integration rule, in the case of the
% cubic hexahedron 3 x 3 x 3.  The shear-strain rule is the full Gauss rule
% appropriate for this element.
    description ='H64-SRI';
    mf =@H64_block;
    femmf =@(fes)femm_deformation_linear_sri(struct('fes',fes, ...
        'material',mater,...
        'integration_rule_volumetric',...
        gauss_rule(struct('dim',3, 'order',3)),...
        'integration_rule_deviatoric',...
        gauss_rule(struct('dim',3, 'order',4))));
    surface_integration_rule=gauss_rule(struct('dim',2, 'order',4));
    execute_simulation (description, mf, femmf, surface_integration_rule);

%% 
% Clearly, the selective reduced integration removed all the oscillations
% and the  approximation of the stress is right on the money. 
%% 
% The same remedy also works for the 27-node hexahedron.  We just have to
% reduce the Gauss rule orders by one.
        description ='H27-SRI';
    mf =@H27_block;
    femmf =@(fes)femm_deformation_linear_sri(struct('fes',fes, ...
        'material',mater,...
        'integration_rule_volumetric',...
        gauss_rule(struct('dim',3, 'order',2)),...
        'integration_rule_deviatoric',...
        gauss_rule(struct('dim',3, 'order',3))));
    surface_integration_rule=gauss_rule(struct('dim',2, 'order',4));
    execute_simulation (description, mf, femmf, surface_integration_rule);

%% 
% Again, oscillations gone, stress is very accurate overall.
%% 
% As a matter of fact, even the least accurate hexahedron available, the H8
% hexahedron with 8  nodes which does not give an acceptable accuracy as a
% rule, is in this case just fine when the selective reduced integration is
% applied.
    %%
    % *Selective reduced integration H8 hexahedron*
    description ='H8-SRI';
    mf =@H8_block;
    femmf =@(fes)femm_deformation_linear_sri(struct('fes',fes, ...
        'material',mater,...
        'integration_rule_volumetric',...
        gauss_rule(struct('dim',3, 'order',1)),...
        'integration_rule_deviatoric',...
        gauss_rule(struct('dim',3, 'order',2))));
    surface_integration_rule=gauss_rule(struct('dim',2, 'order',2));
    execute_simulation (description, mf, femmf, surface_integration_rule);

%% 
% Finally we come back to the T10 tetrahedron.
% The same remedy, selective reduced integration, also works for the
% quadratic tetrahedron.  The deviatoric rule is  the original 4-point one,
% and the volumetric rule is just a single-point quadrature.
%% 
% *Selective reduced integration quadratic tetrahedron*
    description ='T10-SRI';
    mf =@T10_block;
    femmf =@(fes)femm_deformation_linear_sri(struct('fes',fes,...
        'material',mater,...
        'integration_rule_volumetric',tet_rule(struct('npts',1)),...
        'integration_rule_deviatoric',tet_rule(struct('npts',4))));
    surface_integration_rule=tri_rule(struct('npts',3));
    execute_simulation (description, mf, femmf, surface_integration_rule);
    
    
    %%
    % The stresses show a little bit of a loss of accuracy, which presumably
    % is due to the fact that the tetrahedral mesh has some unsymmetry
    % associated with it whereas the hexahedral mesh is perfectly aligned
    % with the boundaries of the modeled wedge/slice.
    
    
%% Discussion
% 
%% 
% If we were simulating the response of  compressible material, for
% instance for $\nu=0.3$ (steel) the finite elements tested above  would
% _all_ work fine. For Poisson's ratio approaching 1/2 ordinary
% isoparametric displacement-based finite elements may fail.
%% 
% For nearly incompressible materials with displacement-based finite
% elements (all of those above) we are always better off using a trick such
% as the selective reduced integration  (or uniform reduced integration for
% the H20 hexahedron) than the full integration.    Sometimes we have the
% option of switching to methods specially designed to deal with
% incompressibility, such as the mixed approximation of pressure plus
% displacement. If that is not available, displacement-only  finite element
% with  a selective reduced integration is a good bet.
end
##### SOURCE END #####
--></body></html>