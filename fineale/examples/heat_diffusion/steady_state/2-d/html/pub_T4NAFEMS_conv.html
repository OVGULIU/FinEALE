
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Two-dimensional heat transfer with convection:  convergence study</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-12-19"><meta name="DC.source" content="pub_T4NAFEMS_conv.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Two-dimensional heat transfer with convection:  convergence study</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Description</a></li><li><a href="#6">Solution</a></li><li><a href="#24">Discussion</a></li></ul></div><p>Link to the  <a href="matlab:edit('pub_T4NAFEMS_conv')">m-file</a>.</p><h2>Description<a name="2"></a></h2><p>Consider a plate of uniform thickness, measuring 0.6 m by 1.0 m. On one short edge the temperature is fixed at 100 &deg;C, and on one long edge the plate is perfectly insulated so that the heat flux is zero through that edge. The other two edges are losing heat via convection to an ambient temperature of 0 &deg;C. The thermal conductivity of the plate is 52.0 W/(m .&deg;K), and the convective heat transfer coefficient is 750 W/(m^2.&deg;K). There is no internal generation of heat. Calculate the temperature 0.2 m along the un-insulated long side, measured from the intersection with the fixed temperature side. The reference result is 18.25 &deg;C.</p><p> <table border=0><tr><td> <img src="../docs/pub_T4NAFEMS_conv.jpg"
width="70%"> </td></tr> <tr><td>Figure 1. Definition of the geometry of
the domain</td></tr> </table> </p><p>The reference temperature at the point A  is 18.25 &deg;C according to the NAFEMS publication (which cites the book Carslaw, H.S. and J.C. Jaeger, Conduction of Heat in Solids. 1959: Oxford University Press).</p><p>The present  tutorial will investigate the reference temperature  and it will attempt to  estimate the  limit value more precisely using a sequence of meshes and Richardson's extrapolation.</p><h2>Solution<a name="6"></a></h2><pre class="codeinput"><span class="keyword">function</span>  pub_T4NAFEMS_conv
</pre><pre class="codeinput">    pu=physical_units_struct;<span class="comment">%  Bring in  definitions of physical units</span>
    kappa=[52 0; 0 52]*pu.W/(pu.M*pu.K); <span class="comment">% conductivity matrix</span>
    h=750*pu.W/(pu.M^2*pu.K);<span class="comment">% surface heat transfer coefficient</span>
    Width=0.6*pu.M;<span class="comment">% Geometrical dimensions</span>
    Height=1.0*pu.M;
    HeightA=0.2*pu.M;
    Thickness=1.0*pu.M;
    mesh_sizes = Height./2.^(2:1:5);<span class="comment">% Mesh sizes for the sequence of simulations</span>
    tolerance =min(mesh_sizes)/1000;
</pre><p>The simulation will be executed inside the loop over all the mesh sizes. The array  <tt>results</tt> will collect the temperatures at point A.</p><pre class="codeinput">    results = [];
    <span class="keyword">for</span> mesh_size = mesh_sizes
</pre><p>Generate the triangle mesh for the current mesh size. Note that we are requesting quadratic triangles to be generated. The domain is given as a sequence of vertices starting at the lower left corner, traversing the boundary in counterclockwise sense.  Edge 1 is between the first and the second vertex and so on.</p><pre class="codeinput">        [fens,fes,groups,edge_fes,edge_groups]=targe2_mesher_vl(<span class="keyword">...</span>
            [0,0; Width,0;  Width,HeightA;   Width,Height;   0,Height; ],<span class="keyword">...</span>
            Thickness,struct(<span class="string">'mesh_size'</span>,mesh_size,<span class="string">'quadratic'</span>,true));
</pre><p>Set up the model data.  The nodes:</p><pre class="codeinput">        clear <span class="string">model_data</span>
        model_data.fens =fens;
</pre><p>The region: note our use of six point quadrature  for the quadratic triangles.</p><pre class="codeinput">        clear <span class="string">region</span>
        region.conductivity =kappa;
        region.fes= fes;
        region.integration_rule =tri_rule(struct(<span class="string">'npts'</span>,6));
        model_data.region{1} =region;
</pre><p>The convection boundary condition is applied along the edges 2,3,4. The elements along the boundary are quadratic line elements L3. The order-four Gauss quadrature is sufficiently accurate.</p><pre class="codeinput">        clear <span class="string">convection</span>
        convection.ambient_temperature=0;
        convection.surface_transfer_coefficient  =h;
        convection.fes = subset(edge_fes,[edge_groups{2},edge_groups{3},edge_groups{4}]);
        convection.integration_rule=gauss_rule(struct(<span class="string">'dim'</span>,1,<span class="string">'order'</span>,4));
        model_data.boundary_conditions.convection{1} = convection;
</pre><p>The prescribed temperature is applied along edge 1 (the bottom edge in Figure 1)..</p><pre class="codeinput">        clear <span class="string">essential</span>
        essential.temperature=100;
        essential.fes = subset(edge_fes,[edge_groups{1}]);
        model_data.boundary_conditions.essential{1} = essential;
</pre><p>The model data is defined, solve for the temperatures.</p><pre class="codeinput">        model_data =heat_diffusion_steady_state(model_data);
</pre><p>Collect the temperature  at the point A  [coordinates (Width,HeightA)].</p><pre class="codeinput">        results =[results,gather_values(model_data.temp,fenode_select(fens,<span class="keyword">...</span>
            struct(<span class="string">'box'</span>,[  Width,Width,HeightA,HeightA],<span class="string">'inflate'</span>, tolerance)))];
</pre><p>Plot the temperature as a raised surface.</p><pre class="codeinput">        model_data.postprocessing.z_scale = 0.01;
        heat_diffusion_plot_raised_surface(model_data);
</pre><img vspace="5" hspace="5" src="pub_T4NAFEMS_conv_01.png" alt=""> <img vspace="5" hspace="5" src="pub_T4NAFEMS_conv_02.png" alt=""> <img vspace="5" hspace="5" src="pub_T4NAFEMS_conv_03.png" alt=""> <img vspace="5" hspace="5" src="pub_T4NAFEMS_conv_04.png" alt=""> <pre class="codeinput">    <span class="keyword">end</span>
</pre><p>These are the computed results for the temperature at point A:</p><pre class="codeinput">results
</pre><pre class="codeoutput">
results =

   1.7785e+01   1.8207e+01   1.8258e+01   1.8256e+01

</pre><p>Richardson extrapolation is used to estimate the true solution from the results for the finest three meshes.</p><pre class="codeinput">   [xestim, beta] = richextrapol(results(end-2:end),mesh_sizes(end-2:end));
    disp([<span class="string">'Estimated true solution for temperature at A: '</span> num2str(xestim) <span class="string">' degrees'</span>])
</pre><pre class="codeoutput">Estimated true solution for temperature at A: 18.256 degrees
</pre><p>Plot the estimated true error.</p><pre class="codeinput">   figure
    loglog(mesh_sizes,abs(results-xestim)/xestim,<span class="string">'bo-'</span>,<span class="string">'linewidth'</span>,3)
    grid <span class="string">on</span>
     xlabel(<span class="string">'log(mesh size)'</span>)
    ylabel(<span class="string">'log(|estimated temperature error|)'</span>)
    set_graphics_defaults
</pre><img vspace="5" hspace="5" src="pub_T4NAFEMS_conv_05.png" alt=""> <p>The estimated true error has  a slope of approximately 4 on the log-log scale.</p><p>Plot the absolute values of the approximate error (differences  of successive solutions).</p><pre class="codeinput">    figure
    loglog(mesh_sizes(2:end),abs(diff(results)),<span class="string">'bo-'</span>,<span class="string">'linewidth'</span>,3)
    grid <span class="string">on</span>
    xlabel(<span class="string">'log(mesh size)'</span>)
    ylabel(<span class="string">'log(|approximate temperature error|)'</span>)
    set_graphics_defaults
</pre><img vspace="5" hspace="5" src="pub_T4NAFEMS_conv_06.png" alt=""> <h2>Discussion<a name="24"></a></h2><p>The last segment  of the approximate error curve is close to the slope of the estimated true error. Nevertheless, it would have been more reassuring if the  three successive approximate errors  were located more closely on a straight line.</p><p>The use of uniform mesh-size meshes is sub optimal: it would be more efficient to use graded meshes. The tutorial pub_T4NAFEMS_conv_graded addresses use of graded meshes  in convergence studies.</p><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Two-dimensional heat transfer with convection:  convergence study
%

%%
% Link to the  <matlab:edit('pub_T4NAFEMS_conv') m-file>.
%

%% Description
%
% Consider a plate of uniform thickness, measuring 0.6 m by 1.0 m. On one
% short edge the temperature is fixed at 100 °C, and on one long edge the
% plate is perfectly insulated so that the heat flux is zero through that
% edge. The other two edges are losing heat via convection to an ambient
% temperature of 0 °C. The thermal conductivity of the plate is 52.0 W/(m
% .°K), and the convective heat transfer coefficient is 750 W/(m^2.°K).
% There is no internal generation of heat. Calculate the temperature 0.2 m
% along the un-insulated long side, measured from the intersection with the
% fixed temperature side. The reference result is 18.25 °C.

%%
%
% <html> <table border=0><tr><td> <img src="../docs/pub_T4NAFEMS_conv.jpg"
% width="70%"> </td></tr> <tr><td>Figure 1. Definition of the geometry of
% the domain</td></tr> </table> </html>


%%
% The reference temperature at the point A  is 18.25 °C according to the
% NAFEMS publication (which cites the book Carslaw, H.S. and J.C. Jaeger,
% Conduction of Heat in Solids. 1959: Oxford University Press).

%%
% The present  tutorial will investigate the reference temperature  and it
% will attempt to  estimate the  limit value more precisely using a
% sequence of meshes and Richardson's extrapolation.

%% Solution
%
function  pub_T4NAFEMS_conv
    pu=physical_units_struct;%  Bring in  definitions of physical units
    kappa=[52 0; 0 52]*pu.W/(pu.M*pu.K); % conductivity matrix
    h=750*pu.W/(pu.M^2*pu.K);% surface heat transfer coefficient
    Width=0.6*pu.M;% Geometrical dimensions
    Height=1.0*pu.M;
    HeightA=0.2*pu.M;
    Thickness=1.0*pu.M;
    mesh_sizes = Height./2.^(2:1:5);% Mesh sizes for the sequence of simulations
    tolerance =min(mesh_sizes)/1000;
    
    
%% 
% The simulation will be executed inside the loop over all the mesh sizes.
% The array  |results| will collect the temperatures at point A.
    results = [];
    for mesh_size = mesh_sizes
        
        %%
        % Generate the triangle mesh for the current mesh size. Note that
        % we are requesting quadratic triangles to be generated. The domain
        % is given as a sequence of vertices starting at the lower left
        % corner, traversing the boundary in counterclockwise sense.  Edge
        % 1 is between the first and the second vertex and so on.
        [fens,fes,groups,edge_fes,edge_groups]=targe2_mesher_vl(...
            [0,0; Width,0;  Width,HeightA;   Width,Height;   0,Height; ],...
            Thickness,struct('mesh_size',mesh_size,'quadratic',true));
        
        %%
        % Set up the model data.  The nodes:
        clear model_data
        model_data.fens =fens;
        
        %%
        % The region: note our use of six point quadrature  for the
        % quadratic triangles.
        clear region
        region.conductivity =kappa;
        region.fes= fes;
        region.integration_rule =tri_rule(struct('npts',6));
        model_data.region{1} =region;
        
        
        %%
        % The convection boundary condition is applied along the edges
        % 2,3,4. The elements along the boundary are quadratic line
        % elements L3. The order-four Gauss quadrature is sufficiently
        % accurate.
        clear convection
        convection.ambient_temperature=0;
        convection.surface_transfer_coefficient  =h;
        convection.fes = subset(edge_fes,[edge_groups{2},edge_groups{3},edge_groups{4}]);
        convection.integration_rule=gauss_rule(struct('dim',1,'order',4));
        model_data.boundary_conditions.convection{1} = convection;
        
        %%
        % The prescribed temperature is applied along edge 1 (the bottom
        % edge in Figure 1)..
        clear essential
        essential.temperature=100;
        essential.fes = subset(edge_fes,[edge_groups{1}]);
        model_data.boundary_conditions.essential{1} = essential;
        
        
        %%
        % The model data is defined, solve for the temperatures.
        model_data =heat_diffusion_steady_state(model_data);
        
        %%
        % Collect the temperature  at the point A  [coordinates
        % (Width,HeightA)].
        results =[results,gather_values(model_data.temp,fenode_select(fens,...
            struct('box',[  Width,Width,HeightA,HeightA],'inflate', tolerance)))];
        
        
        %%
        % Plot the temperature as a raised surface.
        model_data.postprocessing.z_scale = 0.01;
        heat_diffusion_plot_raised_surface(model_data);
        
    end
    
%% 
% These are the computed results for the temperature at point A:
results

%% 
% Richardson extrapolation is used to estimate the true solution from the
% results for the finest three meshes.
   [xestim, beta] = richextrapol(results(end-2:end),mesh_sizes(end-2:end));
    disp(['Estimated true solution for temperature at A: ' num2str(xestim) ' degrees'])
    
%% 
% Plot the estimated true error.
   figure
    loglog(mesh_sizes,abs(results-xestim)/xestim,'bo-','linewidth',3)
    grid on
     xlabel('log(mesh size)')
    ylabel('log(|estimated temperature error|)')
    set_graphics_defaults
    
%% 
% The estimated true error has  a slope of approximately 4 on the log-log
% scale.
%% 
% Plot the absolute values of the approximate error (differences  of
% successive solutions).
    figure
    loglog(mesh_sizes(2:end),abs(diff(results)),'bo-','linewidth',3)
    grid on
    xlabel('log(mesh size)')
    ylabel('log(|approximate temperature error|)')
    set_graphics_defaults
    

%% Discussion
% 
%% 
% The last segment  of the approximate error curve is close to the slope of
% the estimated true error. Nevertheless, it would have been more
% reassuring if the  three successive approximate errors  were located more
% closely on a straight line.
    
%% 
% The use of uniform mesh-size meshes is sub optimal: it would be more
% efficient to use graded meshes. The tutorial pub_T4NAFEMS_conv_graded
% addresses use of graded meshes  in convergence studies.
end
##### SOURCE END #####
--></body></html>