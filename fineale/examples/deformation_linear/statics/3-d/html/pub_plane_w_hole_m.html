
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Infinite plane with a circular hole.</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-01-18"><meta name="DC.source" content="pub_plane_w_hole_m.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Infinite plane with a circular hole.</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Description</a></li><li><a href="#9">Solution</a></li><li><a href="#51">Discussion</a></li></ul></div><p>Link to the  <a href="matlab:edit('pub_plane_w_hole')">m-file</a>.</p><h2>Description<a name="2"></a></h2><p>An infinite medium with a cylindrical hole with circular cross-section of radius <img src="pub_plane_w_hole_m_eq34276.png" alt="$a$">, is subject to uniform tension <img src="pub_plane_w_hole_m_eq57315.png" alt="$T$"> in the X direction (Figure 1). The symmetry of the problem allows us to consider just quarter of the immediate neighborhood of the hole, where the remainder of the infinite medium is replaced with tractions applied  on the exterior boundary.</p><p>
<table border=0><tr><td>
<img src="../docs/plane_w_hole.png" Width=60%>
</td></tr>
<tr><td>Figure 1. Definition of the geometry of the neighborhood of the circular hole in an infinite plane</td></tr>
</table>
</p><p>Analytical solution is available in Reference 1. The stresses in a cylindrical coordinate system are shown in Figure 2.</p><p>
<table border=0><tr><td>
<img src="../docs/pub_hole_1.jpg" Width=50%>
</td></tr>
<tr><td>Figure 2. The stresses in the uniaxial-tension loaded plate in  cylindrical coordinates</td></tr>
</table>
</p><p>References</p><p>1. Sadd, MH, Elasticity.  Theory, Applications, and Numerics, Elsevier, Butterworth Heinemann, 2005.  Page 165:   Example 8-7: Infinite medium with the stress-free hole under  uniform far-field tension loading.</p><h2>Solution<a name="9"></a></h2><p>This tutorial uses the mechanism of bundled algorithms. The solution is obtained with the algorithm deformation_linear_statics().</p><pre class="codeinput"><span class="keyword">function</span> pub_plane_w_hole
</pre><p>We consider  the material properties of steel here, but the solution is in fact independent of  the particular set of material parameters.</p><pre class="codeinput">    U=physical_units_struct;
    E=210000*U.MEGA*U.PA;
    nu=0.3;
</pre><p>The dimensions of the geometry  are as follows:</p><pre class="codeinput">    L= 0.3*U.M; <span class="comment">% in-plane dimension</span>
    W = 0.3*U.M; <span class="comment">% in-plane dimension</span>
    a= 0.15*U.M; <span class="comment">% hole radius</span>
    H = 0.01*U.M; <span class="comment">% thickness of the plate</span>
    tol = a*10e-7;<span class="comment">% Geometrical tolerance</span>
</pre><p>This is the traction applied at infinity in the direction of the axis X.</p><pre class="codeinput">    T=1*U.MEGA*U.PA;
</pre><p>The stress components are derived in Reference 1 as shown in Figure 2. In the functions below  the  stress components are given as functions of location  in the Cartesian coordinates, where <img src="pub_plane_w_hole_m_eq33258.png" alt="$x=r\cos(\theta)$"> and <img src="pub_plane_w_hole_m_eq02522.png" alt="$y=r\sin(\theta)$">.</p><p>Component <img src="pub_plane_w_hole_m_eq00760.png" alt="$\sigma_r(r,\theta)$"></p><pre class="codeinput">    <span class="keyword">function</span> sr =sigmar(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        sr = T/2*(1-a^2/r^2)+T/2*(1+3*a^4/r^4-4*a^2/r^2)*cos(2*th);
    <span class="keyword">end</span>
</pre><p>Component <img src="pub_plane_w_hole_m_eq85253.png" alt="$\sigma_\theta(r,\theta)$"></p><pre class="codeinput">    <span class="keyword">function</span> sth =sigmath(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        sth = T/2*(1+a^2/r^2)-T/2*(1+3*a^4/r^4)*cos(2*th);
    <span class="keyword">end</span>
</pre><p>Component <img src="pub_plane_w_hole_m_eq74103.png" alt="$\sigma_{r\theta}(r,\theta)$"></p><pre class="codeinput">    <span class="keyword">function</span> srth =sigmarth(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        srth = -T/2*(1-3*a^4/r^4+2*a^2/r^2)*sin(2*th);
    <span class="keyword">end</span>
</pre><p>Using the expressions  for the cylindrical-coordinate components of the stress   we can easily derive the Cartesian stress components using the symbolic manipulations in Matlab as</p><pre>   syms T a x r th real %Define symbolic variables
   %  These are the physical components of the stress in cylindrical coords
   sr = T/2*(1-a^2/r^2)+T/2*(1+3*a^4/r^4-4*a^2/r^2)*cos(2*th);
   sth = T/2*(1+a^2/r^2)-T/2*(1+3*a^4/r^4)*cos(2*th);
   srth = -T/2*(1-3*a^4/r^4+2*a^2/r^2)*sin(2*th);
   %This is the transformation matrix
   Rm=[cos(th),sin(th);-sin(th),cos(th)];
   %scart=Matrix of Cartesian components of the stress
   scart=Rm'*[sr,srth;srth,sth]*Rm
   simple(scart)
   %The output may be compared with the functions defined below
   %     for the Cartesian  components of the stress.</pre><p>As the result we obtain  the three  functions for the Cartesian stress components that can be now used to define the tractions on the boundary of the computational domain.</p><pre class="codeinput">    <span class="keyword">function</span> sxx =sigmaxx(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        sxx=(T*(3*a^4*cos(4*th) + 2*r^4 - 3*a^2*r^2*cos(2*th) <span class="keyword">...</span>
            - 2*a^2*r^2*cos(4*th)))/(2*r^4);
    <span class="keyword">end</span>
    <span class="keyword">function</span> syy =sigmayy(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        syy=-(a^2*T*(3*a^2*cos(4*th) + r^2*cos(2*th) <span class="keyword">...</span>
            - 2*r^2*cos(4*th)))/(2*r^4);
    <span class="keyword">end</span>
    <span class="keyword">function</span> sxy =sigmaxy(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        sxy=-(a^2*T*(r^2*sin(2*th) - 3*a^2*sin(4*th) <span class="keyword">...</span>
            + 2*r^2*sin(4*th)))/(2*r^4);;
    <span class="keyword">end</span>
</pre><p>First we will deal with  a 2-D, plane strain model.</p><p>The mesh is constructed using the utility for meshing a block  with an elliptical  hole. These are the numbers of element edges  on the sides of the block and radially.</p><pre class="codeinput">    nL=8; nW=8; na=15;
</pre><p>Note that we are arbitrarily setting the thickness of the slice  to  H.</p><pre class="codeinput">    [fens,fes]=Q4_elliphole(a,a,L,W,nL,nW,na,struct(<span class="string">'other_dimension'</span>,H));
</pre><p>For accuracy  we will convert the original mesh to serendipity quadratic elements.</p><pre class="codeinput">    [fens,fes] = Q4_to_Q8(fens,fes,struct(<span class="string">'other_dimension'</span>,H));


    <span class="comment">% Compose the model data</span>
    clear <span class="string">model_data</span>
    model_data.fens =fens;
</pre><p>The region needs to define the model-dimension reduction method since this is a two-dimensional finite element model.  In this case we're dealing with plane strain.</p><pre class="codeinput">    clear <span class="string">region</span>
    region.fes= fes;
    region.reduction = <span class="string">'strain'</span>;;
    region.E =E;
    region.nu=nu;
    region.integration_rule =gauss_rule(struct(<span class="string">'dim'</span>, 2,<span class="string">'order'</span>, 2));
    model_data.region{1} =region;
</pre><p>The essential boundary conditions are applied on the planes of symmetry.. First <img src="pub_plane_w_hole_m_eq02368.png" alt="$x=0$">:</p><pre class="codeinput">    clear <span class="string">essential</span>
    essential.component= [1];
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,<span class="keyword">...</span>
        struct(<span class="string">'box'</span>,[0,0,-Inf,Inf],<span class="string">'inflate'</span>,tol));
    model_data.boundary_conditions.essential{1} = essential;
</pre><p>Next <img src="pub_plane_w_hole_m_eq51979.png" alt="$y=0$">:</p><pre class="codeinput">    clear <span class="string">essential</span>
    essential.component= [2];
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,<span class="keyword">...</span>
        struct(<span class="string">'box'</span>,[-Inf,Inf,0,0],<span class="string">'inflate'</span>,tol));
    model_data.boundary_conditions.essential{2} = essential;
</pre><p>Now we are going to apply the exact tractions as boundary conditions on the sides of the box. First extract the boundary of the domain:</p><pre class="codeinput">    bdry_fes = mesh_boundary(fes, struct(<span class="string">'other_dimension'</span>,H));
</pre><p>Now select the boundary faces  at <img src="pub_plane_w_hole_m_eq76225.png" alt="$x=L$">.</p><pre class="codeinput">    bclx = fe_select(fens, bdry_fes, <span class="keyword">...</span>
        struct (<span class="string">'box'</span>,[L,L,-Inf,Inf],<span class="string">'inflate'</span>,tol));
    clear <span class="string">traction</span>
    traction.fes =subset(bdry_fes,bclx);;
    traction.traction= @(x) ([sigmaxx(x);sigmaxy(x)]);
    traction.integration_rule =gauss_rule(struct(<span class="string">'dim'</span>, 1,<span class="string">'order'</span>, 3));
    model_data.boundary_conditions.traction{1} = traction;
</pre><p>Now select the boundary faces  at <img src="pub_plane_w_hole_m_eq67285.png" alt="$y=W$">.</p><pre class="codeinput">   bcly = fe_select(fens, bdry_fes, <span class="keyword">...</span>
        struct (<span class="string">'box'</span>,[-Inf,Inf,W,W],<span class="string">'inflate'</span>,tol));
    clear <span class="string">traction</span>
    traction.fes =subset(bdry_fes,bcly);;
    traction.traction= @(x) ([sigmaxy(x);sigmayy(x)]);
    traction.integration_rule =gauss_rule(struct(<span class="string">'dim'</span>, 1,<span class="string">'order'</span>, 3));
    model_data.boundary_conditions.traction{2} = traction;
</pre><p>Solve the model  using the deformation statics algorithm.</p><pre class="codeinput">    model_data =deformation_linear_statics(model_data);
</pre><p>Display the stress <img src="pub_plane_w_hole_m_eq02563.png" alt="$\sigma_{xx}$">.  Use the superconvergent patch recovery for postprocessing accuracy.</p><pre class="codeinput">    model_data.postprocessing.stress_component=1;
    model_data.postprocessing.stress_units=U.MEGA*U.PA;
    model_data.postprocessing.use_spr=1;
    model_data=deformation_plot_stress(model_data);
    view (2);
</pre><img vspace="5" hspace="5" src="pub_plane_w_hole_m_01.png" alt=""> <p>The  display of the stress can be compared with the analytical stress-concentration factor which is 3.0:</p><pre class="codeinput">    sigmaxx([0,a])/T
</pre><pre class="codeoutput">
ans =

     3

</pre><p>Here we are going to display the same information as above but in a slightly different way. We are going to scale the the stress component not with the physical units, but with the maximum stress (attained on the surface of the hole). As a result, the color contours  will be an coding stress values between zero and one (1.0).   Therefore, this is an indication of the accuracy of the predicted magnitude of the stress. Ideally (with perfect accuracy) the maximum value would be 1.0.</p><pre class="codeinput">model_data.postprocessing.gv=[];
    model_data.postprocessing.stress_component=1;
    model_data.postprocessing.stress_units=sigmaxx([0,a]);
    model_data.postprocessing.use_spr=1;
</pre><p>Just for kicks were going to use blue-to-red-through-white colormap.</p><pre class="codeinput">    model_data.postprocessing.colormap=bwr;
    model_data=deformation_plot_stress(model_data);
    view (2);
</pre><img vspace="5" hspace="5" src="pub_plane_w_hole_m_02.png" alt=""> <p>Apparently, the stress concentration is predicted within 1% error.</p><p>The same setup is next solved with a three-dimensional solid mesh.  The initial step is the same:  mesh the  two-dimensional  domain of the neighborhood of the hole.</p><pre class="codeinput">    nL=4; nW=4; na=7;
    [fens,fes]=Q4_elliphole(a,a,L,W,nL,nW,na,struct(<span class="string">'other_dimension'</span>,H));
</pre><p>In the next mesh-construction step we will extrude the cross-section in the thickness direction.</p><pre class="codeinput">    nH=1;<span class="comment">% Number of elements through the thickness</span>
    [fens,fes] = H8_extrude_Q4(fens,fes,nH,@(x,i)([x,0]+[0,0,H*i]));
</pre><p>The  hexahedral elements are now converted to serendipity 20-node bricks.</p><pre class="codeinput">    [fens,fes] = H8_to_H20(fens,fes);
    <span class="comment">%</span>
</pre><p>The formulation of the model data is essentially identical to the one for the plane-strain model.  The differences are few, and they are indicated with</p><pre>%&lt;==</pre><pre class="codeinput">    clear <span class="string">model_data</span>
    model_data.fens =fens;

    clear <span class="string">region</span>
    region.fes= fes;
    region.E =E;
    region.nu=nu;
</pre><p>3-D integration rule.</p><pre class="codeinput">    region.integration_rule =gauss_rule(struct(<span class="string">'dim'</span>, 3,<span class="string">'order'</span>, 2));<span class="comment">%&lt;==</span>
    model_data.region{1} =region;

    clear <span class="string">essential</span>
    essential.component= [1];
    essential.fixed_value= 0;
</pre><p>3-D selection box, here and in the next two essential boundary conditions.</p><pre class="codeinput">    essential.node_list = fenode_select (fens,<span class="keyword">...</span>
        struct(<span class="string">'box'</span>,[0,0,-Inf,Inf,-Inf,Inf],<span class="string">'inflate'</span>,tol));<span class="comment">%&lt;==</span>
    model_data.boundary_conditions.essential{1} = essential;

    clear <span class="string">essential</span>
    essential.component= [2];
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,<span class="keyword">...</span>
        struct(<span class="string">'box'</span>,[-Inf,Inf,0,0,-Inf,Inf],<span class="string">'inflate'</span>,tol));<span class="comment">%&lt;==</span>
    model_data.boundary_conditions.essential{2} = essential;
</pre><p>Note that we are constraining those Z displacements to zero in order to mimic the plane-strain condition.</p><pre class="codeinput">    clear <span class="string">essential</span>
    essential.component= [3];
    essential.fixed_value= 0;
    essential.node_list = [fenode_select(fens,<span class="keyword">...</span>
        struct(<span class="string">'box'</span>,[-Inf,Inf,-Inf,Inf,0,0],<span class="string">'inflate'</span>,tol)),<span class="keyword">...</span>
        fenode_select(fens,<span class="keyword">...</span>
        struct(<span class="string">'box'</span>,[-Inf,Inf,-Inf,Inf,H,H],<span class="string">'inflate'</span>,tol))];<span class="comment">%&lt;==</span>
    model_data.boundary_conditions.essential{3} = essential;

    bdry_fes = mesh_boundary(fes, []);
    bclx = fe_select(fens, bdry_fes, <span class="keyword">...</span>
        struct (<span class="string">'box'</span>,[L,L,-Inf,Inf,-Inf,Inf],<span class="string">'inflate'</span>,tol));
    clear <span class="string">traction</span>
    traction.fes =subset(bdry_fes,bclx);;
</pre><p>3-D traction vector, no forcing in the Z direction, here and below</p><pre class="codeinput">    traction.traction= @(x) ([sigmaxx(x);sigmaxy(x);0]);<span class="comment">%&lt;==</span>
</pre><p>2-D integration rule, here and below.</p><pre class="codeinput">    traction.integration_rule =gauss_rule(struct(<span class="string">'dim'</span>, 2,<span class="string">'order'</span>, 2));<span class="comment">%&lt;==</span>
    model_data.boundary_conditions.traction{1} = traction;

    bcly = fe_select(fens, bdry_fes, <span class="keyword">...</span>
        struct (<span class="string">'box'</span>,[-Inf,Inf,W,W,-Inf,Inf],<span class="string">'inflate'</span>,tol));
    clear <span class="string">traction</span>
    traction.fes =subset(bdry_fes,bcly);;
    traction.traction= @(x) ([sigmaxy(x);sigmayy(x);0]);
    traction.integration_rule =gauss_rule(struct(<span class="string">'dim'</span>, 2,<span class="string">'order'</span>, 2));<span class="comment">%&lt;==</span>
    model_data.boundary_conditions.traction{2} = traction;
</pre><p>Solution and postprocessing are essentially identical to the plane-strain case.</p><pre class="codeinput">    model_data =deformation_linear_statics(model_data);

    model_data.postprocessing.stress_component=1;
    model_data.postprocessing.stress_units=U.MEGA*U.PA;
    model_data.postprocessing.use_spr=1;
    model_data=deformation_plot_stress(model_data);
</pre><img vspace="5" hspace="5" src="pub_plane_w_hole_m_03.png" alt=""> <h2>Discussion<a name="51"></a></h2><p>The hole in an infinite medium is a useful analytical model.  Here we have successfully modeled the situation both with a plane-strain two-coordinate model and a fully-three-dimensional model.</p><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Infinite plane with a circular hole.
%

%%
% Link to the  <matlab:edit('pub_plane_w_hole') m-file>.
%

%% Description
%
%%
% An infinite medium with a cylindrical hole with circular cross-section
% of radius $a$, is subject to uniform tension $T$ in the X direction
% (Figure 1). The symmetry of the problem allows us to consider just
% quarter of the immediate neighborhood of the hole, where the remainder
% of the infinite medium is replaced with tractions applied  on the
% exterior boundary.

%%
%
% <html>
% <table border=0><tr><td>
% <img src="../docs/plane_w_hole.png" Width=60%>
% </td></tr>
% <tr><td>Figure 1. Definition of the geometry of the neighborhood of the circular hole in an infinite plane</td></tr>
% </table>
% </html>
%%
% Analytical solution is available in Reference 1. The stresses in a cylindrical coordinate system are shown in Figure 2.
%%
%
% <html>
% <table border=0><tr><td>
% <img src="../docs/pub_hole_1.jpg" Width=50%>
% </td></tr>
% <tr><td>Figure 2. The stresses in the uniaxial-tension loaded plate in  cylindrical coordinates</td></tr>
% </table>
% </html>

%%
% References
%%
% 1. Sadd, MH, Elasticity.  Theory, Applications, and Numerics, Elsevier,
% Butterworth Heinemann, 2005.  Page 165:   Example 8-7: Infinite
% medium with the stress-free hole under  uniform far-field tension
% loading.

%% Solution
%
%%
%
% This tutorial uses the mechanism of bundled algorithms. The solution
% is obtained with the algorithm deformation_linear_statics().

function pub_plane_w_hole
    
    %%
    % We consider  the material properties of steel here, but the solution is
    % in fact independent of  the particular set of material parameters.
    U=physical_units_struct;
    E=210000*U.MEGA*U.PA;
    nu=0.3;
    
    %%
    % The dimensions of the geometry  are as follows:
    L= 0.3*U.M; % in-plane dimension
    W = 0.3*U.M; % in-plane dimension
    a= 0.15*U.M; % hole radius
    H = 0.01*U.M; % thickness of the plate
    tol = a*10e-7;% Geometrical tolerance
    
    %%
    % This is the traction applied at infinity in the direction of the axis X.
    T=1*U.MEGA*U.PA;
    
    %%
    % The stress components are derived in Reference 1 as shown in Figure 2. In
    % the functions below  the  stress components are given as functions of
    % location  in the Cartesian coordinates, where $x=r\cos(\theta)$ and $y=r\sin(\theta)$.
    %%
    % Component $\sigma_r(r,\theta)$
    function sr =sigmar(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        sr = T/2*(1-a^2/r^2)+T/2*(1+3*a^4/r^4-4*a^2/r^2)*cos(2*th);
    end
    %%
    % Component $\sigma_\theta(r,\theta)$
    function sth =sigmath(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        sth = T/2*(1+a^2/r^2)-T/2*(1+3*a^4/r^4)*cos(2*th);
    end
    %%
    % Component $\sigma_{r\theta}(r,\theta)$
    function srth =sigmarth(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        srth = -T/2*(1-3*a^4/r^4+2*a^2/r^2)*sin(2*th);
    end
    
    
    %%
    % Using the expressions  for the cylindrical-coordinate components of the
    % stress   we can easily derive the Cartesian stress components using the
    % symbolic manipulations in Matlab as
    %%
    %
    %     syms T a x r th real %Define symbolic variables
    %     %  These are the physical components of the stress in cylindrical coords
    %     sr = T/2*(1-a^2/r^2)+T/2*(1+3*a^4/r^4-4*a^2/r^2)*cos(2*th);
    %     sth = T/2*(1+a^2/r^2)-T/2*(1+3*a^4/r^4)*cos(2*th);
    %     srth = -T/2*(1-3*a^4/r^4+2*a^2/r^2)*sin(2*th);
    %     %This is the transformation matrix
    %     Rm=[cos(th),sin(th);-sin(th),cos(th)];
    %     %scart=Matrix of Cartesian components of the stress
    %     scart=Rm'*[sr,srth;srth,sth]*Rm
    %     simple(scart)
    %     %The output may be compared with the functions defined below 
    %     %     for the Cartesian  components of the stress.
    
    %%
    % As the result we obtain  the three  functions for the Cartesian stress
    % components that can be now used to define the tractions on the boundary
    % of the computational domain.
    
    function sxx =sigmaxx(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        sxx=(T*(3*a^4*cos(4*th) + 2*r^4 - 3*a^2*r^2*cos(2*th) ...
            - 2*a^2*r^2*cos(4*th)))/(2*r^4);
    end
    function syy =sigmayy(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        syy=-(a^2*T*(3*a^2*cos(4*th) + r^2*cos(2*th) ...
            - 2*r^2*cos(4*th)))/(2*r^4);
    end
    function sxy =sigmaxy(x)
        r=norm(x(1:2));
        th =atan2(x(2),x(1));
        sxy=-(a^2*T*(r^2*sin(2*th) - 3*a^2*sin(4*th) ...
            + 2*r^2*sin(4*th)))/(2*r^4);;
    end
    
    %%
    % First we will deal with  a 2-D, plane strain model.
    
    %%
    % The mesh is constructed using the utility for meshing a block  with an
    % elliptical  hole. These are the numbers of element edges  on the sides of
    % the block and radially.
    nL=8; nW=8; na=15;
    
    %%
    % Note that we are
    % arbitrarily setting the thickness of the slice  to  H.
    [fens,fes]=Q4_elliphole(a,a,L,W,nL,nW,na,struct('other_dimension',H));
    %%
    % For accuracy  we will convert the original mesh to serendipity quadratic
    % elements.
    [fens,fes] = Q4_to_Q8(fens,fes,struct('other_dimension',H));
    
    
    % Compose the model data
    clear model_data
    model_data.fens =fens;
    
%% 
% The region needs to define the model-dimension reduction method since
% this is a two-dimensional finite element model.  In this case we're
% dealing with plane strain.
    clear region
    region.fes= fes;
    region.reduction = 'strain';;
    region.E =E;
    region.nu=nu;
    region.integration_rule =gauss_rule(struct('dim', 2,'order', 2));
    model_data.region{1} =region;
    
%% 
% The essential boundary conditions are applied on the planes of symmetry..
% First $x=0$:
    clear essential
    essential.component= [1];
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,...
        struct('box',[0,0,-Inf,Inf],'inflate',tol));
    model_data.boundary_conditions.essential{1} = essential;
    
%% 
% Next $y=0$: 
    clear essential
    essential.component= [2];
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,...
        struct('box',[-Inf,Inf,0,0],'inflate',tol));
    model_data.boundary_conditions.essential{2} = essential;
    
%% 
% Now we are going to apply the exact tractions as boundary conditions on
% the sides of the box. First extract the boundary of the domain:
    bdry_fes = mesh_boundary(fes, struct('other_dimension',H));
%% 
% Now select the boundary faces  at $x=L$.
    bclx = fe_select(fens, bdry_fes, ...
        struct ('box',[L,L,-Inf,Inf],'inflate',tol));
    clear traction
    traction.fes =subset(bdry_fes,bclx);;
    traction.traction= @(x) ([sigmaxx(x);sigmaxy(x)]);
    traction.integration_rule =gauss_rule(struct('dim', 1,'order', 3));
    model_data.boundary_conditions.traction{1} = traction;
    
 %% 
% Now select the boundary faces  at $y=W$.
   bcly = fe_select(fens, bdry_fes, ...
        struct ('box',[-Inf,Inf,W,W],'inflate',tol));
    clear traction
    traction.fes =subset(bdry_fes,bcly);;
    traction.traction= @(x) ([sigmaxy(x);sigmayy(x)]);
    traction.integration_rule =gauss_rule(struct('dim', 1,'order', 3));
    model_data.boundary_conditions.traction{2} = traction;
    

%% 
% Solve the model  using the deformation statics algorithm.
    model_data =deformation_linear_statics(model_data);
    
%% 
% Display the stress $\sigma_{xx}$.  Use the superconvergent patch recovery
% for postprocessing accuracy.
    model_data.postprocessing.stress_component=1;
    model_data.postprocessing.stress_units=U.MEGA*U.PA;
    model_data.postprocessing.use_spr=1;
    model_data=deformation_plot_stress(model_data);
    view (2);
    
    %%
    % The  display of the stress can be compared with the analytical
    % stress-concentration factor which is 3.0:
    sigmaxx([0,a])/T
    
    %% 
% Here we are going to display the same information as above but in a
% slightly different way. We are going to scale the the stress component
% not with the physical units, but with the maximum stress (attained on the
% surface of the hole). As a result, the color contours  will be an coding
% stress values between zero and one (1.0).   Therefore, this is an
% indication of the accuracy of the predicted magnitude of the stress.
% Ideally (with perfect accuracy) the maximum value would be 1.0.
model_data.postprocessing.gv=[];
    model_data.postprocessing.stress_component=1;
    model_data.postprocessing.stress_units=sigmaxx([0,a]);
    model_data.postprocessing.use_spr=1;
    
%% 
% Just for kicks were going to use blue-to-red-through-white colormap. 
    model_data.postprocessing.colormap=bwr;
    model_data=deformation_plot_stress(model_data);
    view (2);
%% 
% Apparently, the stress concentration is predicted within 1% error.
    
    %%
    %
    %%
    % The same setup is next solved with a three-dimensional solid mesh.  The
    % initial step is the same:  mesh the  two-dimensional  domain of the
    % neighborhood of the hole.
    nL=4; nW=4; na=7;
    [fens,fes]=Q4_elliphole(a,a,L,W,nL,nW,na,struct('other_dimension',H));

    %%
    % In the next mesh-construction step we will extrude the cross-section in the thickness direction.
    nH=1;% Number of elements through the thickness
    [fens,fes] = H8_extrude_Q4(fens,fes,nH,@(x,i)([x,0]+[0,0,H*i]));
    %%
    % The  hexahedral elements are now converted to serendipity 20-node bricks.
    [fens,fes] = H8_to_H20(fens,fes);
    %
    
%% 
% The formulation of the model data is essentially identical to the one for
% the plane-strain model.  The differences are few, and they are indicated with
%% 
%  %<==
%% 
% 
    clear model_data
    model_data.fens =fens;
    
    clear region
    region.fes= fes;
    region.E =E;
    region.nu=nu;
%% 
% 3-D integration rule.
    region.integration_rule =gauss_rule(struct('dim', 3,'order', 2));%<==
    model_data.region{1} =region;
    
    clear essential
    essential.component= [1];
    essential.fixed_value= 0;
%% 
% 3-D selection box, here and in the next two essential boundary conditions.
    essential.node_list = fenode_select (fens,...
        struct('box',[0,0,-Inf,Inf,-Inf,Inf],'inflate',tol));%<==
    model_data.boundary_conditions.essential{1} = essential;
    
    clear essential
    essential.component= [2];
    essential.fixed_value= 0;
    essential.node_list = fenode_select (fens,...
        struct('box',[-Inf,Inf,0,0,-Inf,Inf],'inflate',tol));%<==
    model_data.boundary_conditions.essential{2} = essential;
    
%% 
% Note that we are constraining those Z displacements to zero in order to
% mimic the plane-strain condition.
    clear essential
    essential.component= [3];
    essential.fixed_value= 0;
    essential.node_list = [fenode_select(fens,...
        struct('box',[-Inf,Inf,-Inf,Inf,0,0],'inflate',tol)),...
        fenode_select(fens,...
        struct('box',[-Inf,Inf,-Inf,Inf,H,H],'inflate',tol))];%<==
    model_data.boundary_conditions.essential{3} = essential;
    
    bdry_fes = mesh_boundary(fes, []);
    bclx = fe_select(fens, bdry_fes, ...
        struct ('box',[L,L,-Inf,Inf,-Inf,Inf],'inflate',tol));
    clear traction
    traction.fes =subset(bdry_fes,bclx);;
%% 
% 3-D traction vector, no forcing in the Z direction, here and below
    traction.traction= @(x) ([sigmaxx(x);sigmaxy(x);0]);%<==
%% 
% 2-D integration rule, here and below.
    traction.integration_rule =gauss_rule(struct('dim', 2,'order', 2));%<==
    model_data.boundary_conditions.traction{1} = traction;
    
    bcly = fe_select(fens, bdry_fes, ...
        struct ('box',[-Inf,Inf,W,W,-Inf,Inf],'inflate',tol));
    clear traction
    traction.fes =subset(bdry_fes,bcly);;
    traction.traction= @(x) ([sigmaxy(x);sigmayy(x);0]);
    traction.integration_rule =gauss_rule(struct('dim', 2,'order', 2));%<==
    model_data.boundary_conditions.traction{2} = traction;
    
    
%% 
% Solution and postprocessing are essentially identical to the plane-strain case.
    model_data =deformation_linear_statics(model_data);
    
    model_data.postprocessing.stress_component=1;
    model_data.postprocessing.stress_units=U.MEGA*U.PA;
    model_data.postprocessing.use_spr=1;
    model_data=deformation_plot_stress(model_data);
%% Discussion
% 
%% 
% The hole in an infinite medium is a useful analytical model.  Here we
% have successfully modeled the situation both with a plane-strain
% two-coordinate model and a fully-three-dimensional model.
end
##### SOURCE END #####
--></body></html>